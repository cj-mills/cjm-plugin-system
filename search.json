[
  {
    "objectID": "core/metadata.html",
    "href": "core/metadata.html",
    "title": "Plugin Metadata",
    "section": "",
    "text": "The PluginMeta dataclass stores metadata about a plugin, including its name, version, and runtime state.\n\nsource\n\n\n\n PluginMeta (name:str, version:str, description:str='', author:str='',\n             package_name:str='', instance:Optional[Any]=None,\n             enabled:bool=True)\n\nMetadata about a plugin.\n\n\n\n\n# Create plugin metadata\nmeta = PluginMeta(\n    name=\"example_plugin\",\n    version=\"1.0.0\",\n    description=\"An example plugin\",\n    author=\"Example Author\"\n)\n\nprint(\"PluginMeta instance:\")\nprint(meta)\nprint(f\"\\nName: {meta.name}\")\nprint(f\"Version: {meta.version}\")\nprint(f\"Enabled: {meta.enabled}\")\nprint(f\"Instance: {meta.instance}\")\n\nPluginMeta instance:\nPluginMeta(name='example_plugin', version='1.0.0', description='An example plugin', author='Example Author', package_name='', instance=None, enabled=True)\n\nName: example_plugin\nVersion: 1.0.0\nEnabled: True\nInstance: None\n\n\n\n# Test with minimal arguments\nminimal_meta = PluginMeta(name=\"minimal\", version=\"0.1.0\")\nprint(f\"Minimal PluginMeta: {minimal_meta}\")\n\n# Test equality\nmeta_copy = PluginMeta(name=\"minimal\", version=\"0.1.0\")\nprint(f\"\\nEquality test: {minimal_meta == meta_copy}\")\n\nMinimal PluginMeta: PluginMeta(name='minimal', version='0.1.0', description='', author='', package_name='', instance=None, enabled=True)\n\nEquality test: True",
    "crumbs": [
      "core",
      "Plugin Metadata"
    ]
  },
  {
    "objectID": "core/metadata.html#pluginmeta",
    "href": "core/metadata.html#pluginmeta",
    "title": "Plugin Metadata",
    "section": "",
    "text": "The PluginMeta dataclass stores metadata about a plugin, including its name, version, and runtime state.\n\nsource\n\n\n\n PluginMeta (name:str, version:str, description:str='', author:str='',\n             package_name:str='', instance:Optional[Any]=None,\n             enabled:bool=True)\n\nMetadata about a plugin.\n\n\n\n\n# Create plugin metadata\nmeta = PluginMeta(\n    name=\"example_plugin\",\n    version=\"1.0.0\",\n    description=\"An example plugin\",\n    author=\"Example Author\"\n)\n\nprint(\"PluginMeta instance:\")\nprint(meta)\nprint(f\"\\nName: {meta.name}\")\nprint(f\"Version: {meta.version}\")\nprint(f\"Enabled: {meta.enabled}\")\nprint(f\"Instance: {meta.instance}\")\n\nPluginMeta instance:\nPluginMeta(name='example_plugin', version='1.0.0', description='An example plugin', author='Example Author', package_name='', instance=None, enabled=True)\n\nName: example_plugin\nVersion: 1.0.0\nEnabled: True\nInstance: None\n\n\n\n# Test with minimal arguments\nminimal_meta = PluginMeta(name=\"minimal\", version=\"0.1.0\")\nprint(f\"Minimal PluginMeta: {minimal_meta}\")\n\n# Test equality\nmeta_copy = PluginMeta(name=\"minimal\", version=\"0.1.0\")\nprint(f\"\\nEquality test: {minimal_meta == meta_copy}\")\n\nMinimal PluginMeta: PluginMeta(name='minimal', version='0.1.0', description='', author='', package_name='', instance=None, enabled=True)\n\nEquality test: True",
    "crumbs": [
      "core",
      "Plugin Metadata"
    ]
  },
  {
    "objectID": "core/interface.html",
    "href": "core/interface.html",
    "title": "Plugin Interface",
    "section": "",
    "text": "The PluginInterface is a generic abstract base class that defines the contract all plugins must implement. This interface is completely domain-agnostic and can be subclassed to create specific plugin systems (e.g., transcription plugins, LLM plugins, image generation plugins).\n\nsource\n\n\n\n PluginInterface ()\n\nGeneric plugin interface that all plugins must implement.\nThis is a domain-agnostic base class. Domain-specific plugin systems should subclass this interface and add their specific requirements.\nImportant: Domain-specific interfaces (direct subclasses of PluginInterface) MUST define the entry_point_group class attribute. This requirement is enforced at class definition time.\nThe interface provides: - Abstract properties for plugin identity (name, version) - Configuration management with JSON Schema validation - Lifecycle methods (initialize, cleanup) - Dependency checking (is_available) - Main execution method (execute) - Optional streaming support via execute_stream",
    "crumbs": [
      "core",
      "Plugin Interface"
    ]
  },
  {
    "objectID": "core/interface.html#plugininterface",
    "href": "core/interface.html#plugininterface",
    "title": "Plugin Interface",
    "section": "",
    "text": "The PluginInterface is a generic abstract base class that defines the contract all plugins must implement. This interface is completely domain-agnostic and can be subclassed to create specific plugin systems (e.g., transcription plugins, LLM plugins, image generation plugins).\n\nsource\n\n\n\n PluginInterface ()\n\nGeneric plugin interface that all plugins must implement.\nThis is a domain-agnostic base class. Domain-specific plugin systems should subclass this interface and add their specific requirements.\nImportant: Domain-specific interfaces (direct subclasses of PluginInterface) MUST define the entry_point_group class attribute. This requirement is enforced at class definition time.\nThe interface provides: - Abstract properties for plugin identity (name, version) - Configuration management with JSON Schema validation - Lifecycle methods (initialize, cleanup) - Dependency checking (is_available) - Main execution method (execute) - Optional streaming support via execute_stream",
    "crumbs": [
      "core",
      "Plugin Interface"
    ]
  },
  {
    "objectID": "core/interface.html#streaming-support",
    "href": "core/interface.html#streaming-support",
    "title": "Plugin Interface",
    "section": "Streaming Support",
    "text": "Streaming Support\nThe plugin system includes optional streaming support. Plugins can implement execute_stream() to provide real-time streaming results.\n\nsource\n\nPluginInterface_execute_stream\n\n PluginInterface_execute_stream (*args, **kwargs)\n\nStream execution results chunk by chunk.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nargs\nVAR_POSITIONAL\nArguments for plugin execution\n\n\nkwargs\nVAR_KEYWORD\n\n\n\nReturns\nGenerator\nYields partial results, returns final result\n\n\n\n\nsource\n\n\nPluginInterface_supports_streaming\n\n PluginInterface_supports_streaming ()\n\nCheck if this plugin supports streaming execution.\nThe default execute_stream implementation falls back to execute() without real streaming. Plugins can override this method to provide true streaming capabilities where partial results are yielded as they become available.\nThe supports_streaming method checks if a plugin has overridden the default execute_stream implementation, allowing callers to detect streaming support at runtime.\nmarkdown### Example: Creating a Domain-Specific Interface\nFirst, letâ€™s create a domain-specific plugin interface that defines the entry_point_group:\n\nfrom typing import List\n\n# Create a domain-specific plugin interface\nclass TextProcessingPlugin(PluginInterface):\n    \"\"\"Domain-specific interface for text processing plugins.\"\"\"\n    \n    # REQUIRED: Define entry_point_group for this plugin type\n    entry_point_group = \"text_processing.plugins\"\n    \n    @property\n    @abstractmethod\n    def supported_formats(self) -&gt; List[str]:\n        \"\"\"File formats this plugin can process.\"\"\"\n        pass\n\n# Now create a concrete plugin that inherits from the domain-specific interface\nclass ExamplePlugin(TextProcessingPlugin):\n    \"\"\"An example text processing plugin implementation.\"\"\"\n    \n    # entry_point_group is inherited from TextProcessingPlugin - no need to redefine!\n\n    def __init__(self):\n        self.logger = logging.getLogger(f\"{__name__}.{type(self).__name__}\")\n        self.config = {}\n        self.resource = None\n\n    @property\n    def name(self) -&gt; str:\n        return \"example_plugin\"\n    \n    @property\n    def version(self) -&gt; str:\n        return \"1.0.0\"\n    \n    @property\n    def supported_formats(self) -&gt; List[str]:\n        return [\"txt\", \"md\"]\n\n    @staticmethod\n    def get_config_schema() -&gt; Dict[str, Any]:\n        \"\"\"Return the configuration schema for this plugin.\"\"\"\n        return {\n            \"type\": \"object\",\n            \"properties\": {\n                \"mode\": {\n                    \"type\": \"string\",\n                    \"enum\": [\"fast\", \"balanced\", \"quality\"],\n                    \"default\": \"balanced\",\n                    \"description\": \"Processing mode\"\n                },\n                \"threshold\": {\n                    \"type\": \"number\",\n                    \"minimum\": 0.0,\n                    \"maximum\": 1.0,\n                    \"default\": 0.5,\n                    \"description\": \"Processing threshold\"\n                },\n                \"max_workers\": {\n                    \"type\": \"integer\",\n                    \"minimum\": 1,\n                    \"maximum\": 16,\n                    \"default\": 4,\n                    \"description\": \"Maximum number of workers\"\n                },\n                \"enable_cache\": {\n                    \"type\": \"boolean\",\n                    \"default\": True,\n                    \"description\": \"Enable result caching\"\n                }\n            },\n            \"required\": [\"mode\"]\n        }\n    \n    def get_current_config(self) -&gt; Dict[str, Any]:\n        \"\"\"Return the current configuration.\"\"\"\n        # Merge defaults with actual config\n        defaults = self.get_config_defaults()\n        return {**defaults, **self.config}\n    \n    def initialize(self, config: Optional[Dict[str, Any]] = None) -&gt; None:\n        \"\"\"Initialize the plugin.\"\"\"\n        if config:\n            is_valid, error = self.validate_config(config)\n            if not is_valid:\n                raise ValueError(f\"Invalid configuration: {error}\")\n        \n        # Merge provided config with defaults\n        defaults = self.get_config_defaults()\n        self.config = {**defaults, **(config or {})}\n        \n        self.logger.info(f\"Initializing {self.name} with config: {self.config}\")\n        \n        # Simulate resource initialization\n        mode = self.config.get(\"mode\", \"balanced\")\n        self.resource = f\"Resource-{mode}\"\n    \n    def execute(self, input_data: Any, **kwargs) -&gt; Any:\n        \"\"\"Execute the plugin's functionality.\"\"\"\n        self.logger.info(f\"Executing {self.name} with resource: {self.resource}\")\n        self.logger.info(f\"Config: {self.config}\")\n        return f\"Processed {input_data} using {self.resource}\"\n\n    def is_available(self) -&gt; bool:\n        \"\"\"Check availability.\"\"\"\n        return True\n    \n    def cleanup(self) -&gt; None:\n        \"\"\"Clean up resources.\"\"\"\n        self.logger.info(f\"Cleaning up {self.name}\")\n        self.resource = None\n\n\n# Test the example plugin\nlogging.basicConfig(level=logging.INFO)\n\nplugin = ExamplePlugin()\nprint(f\"Plugin: {plugin.name} v{plugin.version}\")\nprint(f\"Available: {plugin.is_available()}\")\nprint(f\"Entry point group (inherited): {plugin.entry_point_group}\")\n\n# Get schema and defaults\nimport json\nschema = plugin.get_config_schema()\nprint(\"\\nConfiguration Schema:\")\nprint(json.dumps(schema, indent=2))\n\ndefaults = plugin.get_config_defaults()\nprint(\"\\nDefault Configuration:\")\nprint(json.dumps(defaults, indent=2))\n\nPlugin: example_plugin v1.0.0\nAvailable: True\nEntry point group (inherited): text_processing.plugins\n\nConfiguration Schema:\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"mode\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"fast\",\n        \"balanced\",\n        \"quality\"\n      ],\n      \"default\": \"balanced\",\n      \"description\": \"Processing mode\"\n    },\n    \"threshold\": {\n      \"type\": \"number\",\n      \"minimum\": 0.0,\n      \"maximum\": 1.0,\n      \"default\": 0.5,\n      \"description\": \"Processing threshold\"\n    },\n    \"max_workers\": {\n      \"type\": \"integer\",\n      \"minimum\": 1,\n      \"maximum\": 16,\n      \"default\": 4,\n      \"description\": \"Maximum number of workers\"\n    },\n    \"enable_cache\": {\n      \"type\": \"boolean\",\n      \"default\": true,\n      \"description\": \"Enable result caching\"\n    }\n  },\n  \"required\": [\n    \"mode\"\n  ]\n}\n\nDefault Configuration:\n{\n  \"mode\": \"balanced\",\n  \"threshold\": 0.5,\n  \"max_workers\": 4,\n  \"enable_cache\": true\n}\n\n\n\n# This will raise a TypeError because entry_point_group is not defined\ntry:\n    class BadPlugin(PluginInterface):\n        \"\"\"This will fail - missing entry_point_group!\"\"\"\n        pass\nexcept TypeError as e:\n    print(\"âœ“ Correctly caught missing entry_point_group:\")\n    print(f\"  {e}\")\n\nprint(\"\\n\" + \"=\"*60 + \"\\n\")\n\n# This works - entry_point_group is defined\ntry:\n    class GoodPlugin(PluginInterface):\n        \"\"\"This works - has entry_point_group!\"\"\"\n        entry_point_group = \"good.plugins\"\n    print(\"âœ“ Successfully created domain-specific interface with entry_point_group\")\n    print(f\"  entry_point_group = '{GoodPlugin.entry_point_group}'\")\nexcept TypeError as e:\n    print(f\"âœ— Unexpected error: {e}\")\n\nâœ“ Correctly caught missing entry_point_group:\n  Domain-specific interface 'BadPlugin' must define 'entry_point_group' class attribute. Example:\n    class BadPlugin(PluginInterface):\n        entry_point_group = 'your.plugins'\n\n============================================================\n\nâœ“ Successfully created domain-specific interface with entry_point_group\n  entry_point_group = 'good.plugins'\n\n\n\n\nDemonstrating entry_point_group Enforcement\nThe system enforces that domain-specific interfaces (direct subclasses of PluginInterface) must define entry_point_group:\n\n# Initialize and execute\nplugin.initialize({\"mode\": \"quality\", \"threshold\": 0.8})\nresult = plugin.execute(\"sample_data\")\nprint(f\"\\nResult: {result}\")\n\n# Get current config\ncurrent = plugin.get_current_config()\nprint(\"\\nCurrent Configuration:\")\nprint(json.dumps(current, indent=2))\n\n# Cleanup\nplugin.cleanup()\n\nINFO:__main__.ExamplePlugin:Initializing example_plugin with config: {'mode': 'quality', 'threshold': 0.8, 'max_workers': 4, 'enable_cache': True}\nINFO:__main__.ExamplePlugin:Executing example_plugin with resource: Resource-quality\nINFO:__main__.ExamplePlugin:Config: {'mode': 'quality', 'threshold': 0.8, 'max_workers': 4, 'enable_cache': True}\nINFO:__main__.ExamplePlugin:Cleaning up example_plugin\n\n\n\nResult: Processed sample_data using Resource-quality\n\nCurrent Configuration:\n{\n  \"mode\": \"quality\",\n  \"threshold\": 0.8,\n  \"max_workers\": 4,\n  \"enable_cache\": true\n}\n\n\n\n# Test configuration validation\ntest_configs = [\n    ({\"mode\": \"fast\"}, \"Valid minimal config\"),\n    ({\"mode\": \"invalid\"}, \"Invalid mode value\"),\n    ({\"threshold\": 0.5}, \"Missing required 'mode' field\"),\n    ({\"mode\": \"balanced\", \"threshold\": 2.0}, \"Threshold exceeds maximum\"),\n]\n\nprint(\"\\nConfiguration Validation Tests:\")\nfor config, description in test_configs:\n    is_valid, error = plugin.validate_config(config)\n    print(f\"\\n{description}:\")\n    print(f\"  Config: {config}\")\n    print(f\"  Valid: {is_valid}\")\n    if error:\n        print(f\"  Error: {error[:80]}...\")  # Truncate long errors\n\n\nConfiguration Validation Tests:\n\nValid minimal config:\n  Config: {'mode': 'fast'}\n  Valid: True\n\nInvalid mode value:\n  Config: {'mode': 'invalid'}\n  Valid: False\n  Error: 'invalid' is not one of ['fast', 'balanced', 'quality']\n\nFailed validating 'enum...\n\nMissing required 'mode' field:\n  Config: {'threshold': 0.5}\n  Valid: False\n  Error: 'mode' is a required property\n\nFailed validating 'required' in schema:\n    {'typ...\n\nThreshold exceeds maximum:\n  Config: {'mode': 'balanced', 'threshold': 2.0}\n  Valid: False\n  Error: 2.0 is greater than the maximum of 1.0\n\nFailed validating 'maximum' in schema['p...\n\n\n\n# Test streaming support\nprint(f\"\\nSupports streaming: {plugin.supports_streaming()}\")\n\n# The default implementation doesn't stream, it just yields the result once\nprint(\"\\nStreaming execution:\")\nfor chunk in plugin.execute_stream(\"stream_data\"):\n    print(f\"  Chunk: {chunk}\")\n\nINFO:__main__.ExamplePlugin:Executing example_plugin with resource: None\nINFO:__main__.ExamplePlugin:Config: {'mode': 'quality', 'threshold': 0.8, 'max_workers': 4, 'enable_cache': True}\n\n\n\nSupports streaming: False\n\nStreaming execution:\n  Chunk: Processed stream_data using None",
    "crumbs": [
      "core",
      "Plugin Interface"
    ]
  },
  {
    "objectID": "utils/validation.html",
    "href": "utils/validation.html",
    "title": "Configuration Validation",
    "section": "",
    "text": "These functions provide JSON Schema validation with graceful fallback when jsonschema is not available.\n\nsource\n\n\n\n validate_config (config:Dict[str,Any], schema:Dict[str,Any])\n\nValidate a configuration dictionary against a JSON Schema.\n\n\n\n\nType\nDetails\n\n\n\n\nconfig\nDict\nConfiguration to validate\n\n\nschema\nDict\nJSON Schema to validate against\n\n\nReturns\nTuple\n(is_valid, error_message)\n\n\n\nUses the jsonschema library for full validation if available, otherwise falls back to basic validation.\nThe basic validation (when jsonschema is not installed) provides minimal support checking: - Required fields - Field types - Enum values - Numeric constraints (minimum, maximum)\n\nsource\n\n\n\n\n extract_defaults (schema:Dict[str,Any])\n\nExtract default values from a JSON Schema.\n\n\n\n\nType\nDetails\n\n\n\n\nschema\nDict\nJSON Schema\n\n\nReturns\nDict\nDefault values from schema\n\n\n\n\n\n\n\nimport json\n\n# Define a schema\nschema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"model\": {\n            \"type\": \"string\",\n            \"enum\": [\"tiny\", \"base\", \"small\", \"medium\", \"large\"],\n            \"default\": \"base\",\n            \"description\": \"Model size to use\"\n        },\n        \"temperature\": {\n            \"type\": \"number\",\n            \"minimum\": 0.0,\n            \"maximum\": 1.0,\n            \"default\": 0.0\n        },\n        \"batch_size\": {\n            \"type\": \"integer\",\n            \"minimum\": 1,\n            \"maximum\": 32,\n            \"default\": 8\n        }\n    },\n    \"required\": [\"model\"]\n}\n\nprint(\"Schema:\")\nprint(json.dumps(schema, indent=2))\n\nSchema:\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"model\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"tiny\",\n        \"base\",\n        \"small\",\n        \"medium\",\n        \"large\"\n      ],\n      \"default\": \"base\",\n      \"description\": \"Model size to use\"\n    },\n    \"temperature\": {\n      \"type\": \"number\",\n      \"minimum\": 0.0,\n      \"maximum\": 1.0,\n      \"default\": 0.0\n    },\n    \"batch_size\": {\n      \"type\": \"integer\",\n      \"minimum\": 1,\n      \"maximum\": 32,\n      \"default\": 8\n    }\n  },\n  \"required\": [\n    \"model\"\n  ]\n}\n\n\n\n# Test valid configurations\nvalid_configs = [\n    {\"model\": \"tiny\"},\n    {\"model\": \"base\", \"temperature\": 0.5},\n    {\"model\": \"large\", \"batch_size\": 16}\n]\n\nprint(\"\\nValidating valid configurations:\")\nfor config in valid_configs:\n    is_valid, error = validate_config(config, schema)\n    print(f\"Config: {config}\")\n    print(f\"  Valid: {is_valid}\")\n    if error:\n        print(f\"  Error: {error}\")\n\n\nValidating valid configurations:\nConfig: {'model': 'tiny'}\n  Valid: True\nConfig: {'model': 'base', 'temperature': 0.5}\n  Valid: True\nConfig: {'model': 'large', 'batch_size': 16}\n  Valid: True\n\n\n\n# Test invalid configurations\ninvalid_configs = [\n    ({\"temperature\": 0.5}, \"Missing required 'model' field\"),\n    ({\"model\": \"invalid\"}, \"Invalid enum value\"),\n    ({\"model\": \"base\", \"temperature\": 1.5}, \"Temperature exceeds maximum\"),\n    ({\"model\": \"base\", \"batch_size\": 100}, \"Batch size exceeds maximum\")\n]\n\nprint(\"\\nValidating invalid configurations:\")\nfor config, description in invalid_configs:\n    is_valid, error = validate_config(config, schema)\n    print(f\"\\n{description}:\")\n    print(f\"  Config: {config}\")\n    print(f\"  Valid: {is_valid}\")\n    if error:\n        print(f\"  Error: {error[:100]}...\")  # Truncate long errors\n\n\nValidating invalid configurations:\n\nMissing required 'model' field:\n  Config: {'temperature': 0.5}\n  Valid: False\n  Error: 'model' is a required property\n\nFailed validating 'required' in schema:\n    {'type': 'object',\n     ...\n\nInvalid enum value:\n  Config: {'model': 'invalid'}\n  Valid: False\n  Error: 'invalid' is not one of ['tiny', 'base', 'small', 'medium', 'large']\n\nFailed validating 'enum' in sc...\n\nTemperature exceeds maximum:\n  Config: {'model': 'base', 'temperature': 1.5}\n  Valid: False\n  Error: 1.5 is greater than the maximum of 1.0\n\nFailed validating 'maximum' in schema['properties']['tempera...\n\nBatch size exceeds maximum:\n  Config: {'model': 'base', 'batch_size': 100}\n  Valid: False\n  Error: 100 is greater than the maximum of 32\n\nFailed validating 'maximum' in schema['properties']['batch_si...\n\n\n\n# Test extracting defaults\ndefaults = extract_defaults(schema)\nprint(\"\\nDefault values extracted from schema:\")\nprint(json.dumps(defaults, indent=2))\n\n\nDefault values extracted from schema:\n{\n  \"model\": \"base\",\n  \"temperature\": 0.0,\n  \"batch_size\": 8\n}",
    "crumbs": [
      "utils",
      "Configuration Validation"
    ]
  },
  {
    "objectID": "utils/validation.html#validation-functions",
    "href": "utils/validation.html#validation-functions",
    "title": "Configuration Validation",
    "section": "",
    "text": "These functions provide JSON Schema validation with graceful fallback when jsonschema is not available.\n\nsource\n\n\n\n validate_config (config:Dict[str,Any], schema:Dict[str,Any])\n\nValidate a configuration dictionary against a JSON Schema.\n\n\n\n\nType\nDetails\n\n\n\n\nconfig\nDict\nConfiguration to validate\n\n\nschema\nDict\nJSON Schema to validate against\n\n\nReturns\nTuple\n(is_valid, error_message)\n\n\n\nUses the jsonschema library for full validation if available, otherwise falls back to basic validation.\nThe basic validation (when jsonschema is not installed) provides minimal support checking: - Required fields - Field types - Enum values - Numeric constraints (minimum, maximum)\n\nsource\n\n\n\n\n extract_defaults (schema:Dict[str,Any])\n\nExtract default values from a JSON Schema.\n\n\n\n\nType\nDetails\n\n\n\n\nschema\nDict\nJSON Schema\n\n\nReturns\nDict\nDefault values from schema\n\n\n\n\n\n\n\nimport json\n\n# Define a schema\nschema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"model\": {\n            \"type\": \"string\",\n            \"enum\": [\"tiny\", \"base\", \"small\", \"medium\", \"large\"],\n            \"default\": \"base\",\n            \"description\": \"Model size to use\"\n        },\n        \"temperature\": {\n            \"type\": \"number\",\n            \"minimum\": 0.0,\n            \"maximum\": 1.0,\n            \"default\": 0.0\n        },\n        \"batch_size\": {\n            \"type\": \"integer\",\n            \"minimum\": 1,\n            \"maximum\": 32,\n            \"default\": 8\n        }\n    },\n    \"required\": [\"model\"]\n}\n\nprint(\"Schema:\")\nprint(json.dumps(schema, indent=2))\n\nSchema:\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"model\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"tiny\",\n        \"base\",\n        \"small\",\n        \"medium\",\n        \"large\"\n      ],\n      \"default\": \"base\",\n      \"description\": \"Model size to use\"\n    },\n    \"temperature\": {\n      \"type\": \"number\",\n      \"minimum\": 0.0,\n      \"maximum\": 1.0,\n      \"default\": 0.0\n    },\n    \"batch_size\": {\n      \"type\": \"integer\",\n      \"minimum\": 1,\n      \"maximum\": 32,\n      \"default\": 8\n    }\n  },\n  \"required\": [\n    \"model\"\n  ]\n}\n\n\n\n# Test valid configurations\nvalid_configs = [\n    {\"model\": \"tiny\"},\n    {\"model\": \"base\", \"temperature\": 0.5},\n    {\"model\": \"large\", \"batch_size\": 16}\n]\n\nprint(\"\\nValidating valid configurations:\")\nfor config in valid_configs:\n    is_valid, error = validate_config(config, schema)\n    print(f\"Config: {config}\")\n    print(f\"  Valid: {is_valid}\")\n    if error:\n        print(f\"  Error: {error}\")\n\n\nValidating valid configurations:\nConfig: {'model': 'tiny'}\n  Valid: True\nConfig: {'model': 'base', 'temperature': 0.5}\n  Valid: True\nConfig: {'model': 'large', 'batch_size': 16}\n  Valid: True\n\n\n\n# Test invalid configurations\ninvalid_configs = [\n    ({\"temperature\": 0.5}, \"Missing required 'model' field\"),\n    ({\"model\": \"invalid\"}, \"Invalid enum value\"),\n    ({\"model\": \"base\", \"temperature\": 1.5}, \"Temperature exceeds maximum\"),\n    ({\"model\": \"base\", \"batch_size\": 100}, \"Batch size exceeds maximum\")\n]\n\nprint(\"\\nValidating invalid configurations:\")\nfor config, description in invalid_configs:\n    is_valid, error = validate_config(config, schema)\n    print(f\"\\n{description}:\")\n    print(f\"  Config: {config}\")\n    print(f\"  Valid: {is_valid}\")\n    if error:\n        print(f\"  Error: {error[:100]}...\")  # Truncate long errors\n\n\nValidating invalid configurations:\n\nMissing required 'model' field:\n  Config: {'temperature': 0.5}\n  Valid: False\n  Error: 'model' is a required property\n\nFailed validating 'required' in schema:\n    {'type': 'object',\n     ...\n\nInvalid enum value:\n  Config: {'model': 'invalid'}\n  Valid: False\n  Error: 'invalid' is not one of ['tiny', 'base', 'small', 'medium', 'large']\n\nFailed validating 'enum' in sc...\n\nTemperature exceeds maximum:\n  Config: {'model': 'base', 'temperature': 1.5}\n  Valid: False\n  Error: 1.5 is greater than the maximum of 1.0\n\nFailed validating 'maximum' in schema['properties']['tempera...\n\nBatch size exceeds maximum:\n  Config: {'model': 'base', 'batch_size': 100}\n  Valid: False\n  Error: 100 is greater than the maximum of 32\n\nFailed validating 'maximum' in schema['properties']['batch_si...\n\n\n\n# Test extracting defaults\ndefaults = extract_defaults(schema)\nprint(\"\\nDefault values extracted from schema:\")\nprint(json.dumps(defaults, indent=2))\n\n\nDefault values extracted from schema:\n{\n  \"model\": \"base\",\n  \"temperature\": 0.0,\n  \"batch_size\": 8\n}",
    "crumbs": [
      "utils",
      "Configuration Validation"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "cjm-plugin-system",
    "section": "",
    "text": "pip install cjm_plugin_system",
    "crumbs": [
      "cjm-plugin-system"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "cjm-plugin-system",
    "section": "",
    "text": "pip install cjm_plugin_system",
    "crumbs": [
      "cjm-plugin-system"
    ]
  },
  {
    "objectID": "index.html#project-structure",
    "href": "index.html#project-structure",
    "title": "cjm-plugin-system",
    "section": "Project Structure",
    "text": "Project Structure\nnbs/\nâ”œâ”€â”€ core/ (3)\nâ”‚   â”œâ”€â”€ interface.ipynb  # Abstract base class defining the generic plugin interface\nâ”‚   â”œâ”€â”€ manager.ipynb    # Plugin discovery, loading, and lifecycle management system\nâ”‚   â””â”€â”€ metadata.ipynb   # Data structures for plugin metadata\nâ””â”€â”€ utils/ (1)\n    â””â”€â”€ validation.ipynb  # JSON Schema validation helpers for plugin configuration\nTotal: 4 notebooks across 2 directories",
    "crumbs": [
      "cjm-plugin-system"
    ]
  },
  {
    "objectID": "index.html#module-dependencies",
    "href": "index.html#module-dependencies",
    "title": "cjm-plugin-system",
    "section": "Module Dependencies",
    "text": "Module Dependencies\ngraph LR\n    core_interface[core.interface&lt;br/&gt;Plugin Interface]\n    core_manager[core.manager&lt;br/&gt;Plugin Manager]\n    core_metadata[core.metadata&lt;br/&gt;Plugin Metadata]\n    utils_validation[utils.validation&lt;br/&gt;Configuration Validation]\n\n    core_interface --&gt; utils_validation\n    core_manager --&gt; core_metadata\n    core_manager --&gt; core_interface\n3 cross-module dependencies detected",
    "crumbs": [
      "cjm-plugin-system"
    ]
  },
  {
    "objectID": "index.html#cli-reference",
    "href": "index.html#cli-reference",
    "title": "cjm-plugin-system",
    "section": "CLI Reference",
    "text": "CLI Reference\nNo CLI commands found in this project.",
    "crumbs": [
      "cjm-plugin-system"
    ]
  },
  {
    "objectID": "index.html#module-overview",
    "href": "index.html#module-overview",
    "title": "cjm-plugin-system",
    "section": "Module Overview",
    "text": "Module Overview\nDetailed documentation for each module in the project:\n\nPlugin Interface (interface.ipynb)\n\nAbstract base class defining the generic plugin interface\n\n\nImport\nfrom cjm_plugin_system.core.interface import (\n    PluginInterface,\n    PluginInterface_supports_streaming,\n    PluginInterface_execute_stream\n)\n\n\nFunctions\ndef PluginInterface_supports_streaming(self) -&gt; bool: # True if execute_stream is implemented\n    \"\"\"Check if this plugin supports streaming execution.\"\"\"\n    # Default: check if execute_stream is overridden from the base class\n    \"Check if this plugin supports streaming execution.\"\ndef PluginInterface_execute_stream(\n    self,\n    *args, # Arguments for plugin execution\n    **kwargs # Keyword arguments for plugin execution\n) -&gt; Generator[Any, None, Any]: # Yields partial results, returns final result\n    \"Stream execution results chunk by chunk.\"\n\n\nClasses\nclass PluginInterface(ABC):\n    \"Generic plugin interface that all plugins must implement.\"\n    \n    def name(self) -&gt; str: # Unique identifier for this plugin\n            \"\"\"Unique plugin identifier.\"\"\"\n            pass\n    \n        @property\n        @abstractmethod\n        def version(self) -&gt; str: # Semantic version string (e.g., \"1.0.0\")\n        \"Unique plugin identifier.\"\n    \n    def version(self) -&gt; str: # Semantic version string (e.g., \"1.0.0\")\n            \"\"\"Plugin version.\"\"\"\n            pass\n    \n        @abstractmethod\n        def initialize(\n            self,\n            config:Optional[Dict[str, Any]]=None # Configuration dictionary for plugin-specific settings\n        ) -&gt; None\n        \"Plugin version.\"\n    \n    def initialize(\n            self,\n            config:Optional[Dict[str, Any]]=None # Configuration dictionary for plugin-specific settings\n        ) -&gt; None\n        \"Initialize the plugin with configuration.\"\n    \n    def execute(\n            self,\n            *args,\n            **kwargs\n        ) -&gt; Any: # Plugin-specific output\n        \"Execute the plugin's main functionality.\"\n    \n    def is_available(self) -&gt; bool: # True if all required dependencies are available\n            \"\"\"Check if the plugin's dependencies are available.\"\"\"\n            pass\n    \n        @staticmethod\n        @abstractmethod\n        def get_config_schema() -&gt; Dict[str, Any]: # JSON Schema describing configuration options\n        \"Check if the plugin's dependencies are available.\"\n    \n    def get_config_schema() -&gt; Dict[str, Any]: # JSON Schema describing configuration options\n            \"\"\"Return JSON Schema describing the plugin's configuration options.\"\"\"\n            pass\n    \n        @abstractmethod\n        def get_current_config(self) -&gt; Dict[str, Any]: # Current configuration state\n        \"Return JSON Schema describing the plugin's configuration options.\"\n    \n    def get_current_config(self) -&gt; Dict[str, Any]: # Current configuration state\n            \"\"\"Return the current configuration state.\"\"\"\n            pass\n    \n        def validate_config(\n            self,\n            config:Dict[str, Any] # Configuration to validate\n        ) -&gt; Tuple[bool, Optional[str]]: # (is_valid, error_message)\n        \"Return the current configuration state.\"\n    \n    def validate_config(\n            self,\n            config:Dict[str, Any] # Configuration to validate\n        ) -&gt; Tuple[bool, Optional[str]]: # (is_valid, error_message)\n        \"Validate a configuration dictionary against the schema.\"\n    \n    def get_config_defaults(self) -&gt; Dict[str, Any]: # Default values from schema\n            \"\"\"Extract default values from the configuration schema.\"\"\"\n            schema = self.get_config_schema()\n            return extract_defaults(schema)\n    \n        def cleanup(self) -&gt; None\n        \"Extract default values from the configuration schema.\"\n    \n    def cleanup(self) -&gt; None\n        \"Optional cleanup when plugin is unloaded.\"\n\n\n\nPlugin Manager (manager.ipynb)\n\nPlugin discovery, loading, and lifecycle management system\n\n\nImport\nfrom cjm_plugin_system.core.manager import (\n    PluginManager,\n    get_plugin_config_schema,\n    get_plugin_config,\n    update_plugin_config,\n    validate_plugin_config,\n    get_all_plugin_schemas,\n    reload_plugin,\n    execute_plugin_stream,\n    check_streaming_support,\n    get_streaming_plugins\n)\n\n\nFunctions\ndef get_plugin_config_schema(\n    self,\n    plugin_name:str # Name of the plugin\n) -&gt; Optional[Dict[str, Any]]: # Configuration schema or None if plugin not found\n    \"Get the configuration schema for a plugin.\"\ndef get_plugin_config(\n    self,\n    plugin_name:str # Name of the plugin\n) -&gt; Optional[Dict[str, Any]]: # Current configuration or None if plugin not found\n    \"Get the current configuration of a plugin.\"\ndef update_plugin_config(\n    self,\n    plugin_name:str, # Name of the plugin\n    config:Dict[str, Any], # New configuration\n    merge:bool=True # Whether to merge with existing config or replace entirely\n) -&gt; bool: # True if successful, False otherwise\n    \"Update a plugin's configuration and reinitialize it.\"\ndef validate_plugin_config(\n    self,\n    plugin_name:str, # Name of the plugin\n    config:Dict[str, Any] # Configuration to validate\n) -&gt; Tuple[bool, Optional[str]]: # (is_valid, error_message)\n    \"Validate a configuration dictionary for a plugin without applying it.\"\ndef get_all_plugin_schemas(\n    self\n) -&gt; Dict[str, Dict[str, Any]]: # Dictionary mapping plugin names to their schemas\n    \"Get configuration schemas for all loaded plugins.\"\ndef reload_plugin(\n    self,\n    plugin_name:str, # Name of the plugin to reload\n    config:Optional[Dict[str, Any]]=None # Optional new configuration\n) -&gt; bool: # True if successful, False otherwise\n    \"Reload a plugin with optional new configuration.\"\ndef execute_plugin_stream(\n    self,\n    plugin_name:str, # Name of the plugin to execute\n    *args, # Arguments to pass to the plugin\n    **kwargs # Keyword arguments to pass to the plugin\n) -&gt; Generator[Any, None, Any]: # Generator yielding partial results, returns final result\n    \"Execute a plugin with streaming support if available.\"\ndef check_streaming_support(\n    self,\n    plugin_name:str # Name of the plugin to check\n) -&gt; bool: # True if plugin supports streaming\n    \"Check if a plugin supports streaming execution.\"\ndef get_streaming_plugins(\n    self\n) -&gt; List[str]: # List of plugin names that support streaming\n    \"Get a list of all loaded plugins that support streaming.\"\n\n\nClasses\nclass PluginManager:\n    def __init__(\n        self,\n        plugin_interface:Type[PluginInterface]=PluginInterface, # Base class/interface plugins must implement\n        entry_point_group:Optional[str]=None # Optional override for entry point group name\n    )\n    \"Manages plugin discovery, loading, and lifecycle.\"\n    \n    def __init__(\n            self,\n            plugin_interface:Type[PluginInterface]=PluginInterface, # Base class/interface plugins must implement\n            entry_point_group:Optional[str]=None # Optional override for entry point group name\n        )\n        \"Initialize the plugin manager.\"\n    \n    def get_entry_points(self) -&gt; importlib.metadata.EntryPoints: # Entry points for the configured group\n            \"\"\"Get plugin entry points from installed packages.\"\"\"\n            self.entry_points = []\n            try\n        \"Get plugin entry points from installed packages.\"\n    \n    def discover_plugins(self) -&gt; List[PluginMeta]: # List of discovered plugin metadata objects\n            \"\"\"Discover all installed plugins via entry points.\"\"\"\n            self.discovered = []\n    \n            for ep in self.entry_points\n        \"Discover all installed plugins via entry points.\"\n    \n    def load_plugin(\n            self,\n            plugin_meta:PluginMeta, # Plugin metadata\n            config:Optional[Dict[str, Any]]=None # Optional configuration for the plugin\n        ) -&gt; bool: # True if successfully loaded, False otherwise\n        \"Load and initialize a plugin.\"\n    \n    def load_plugin_from_module(\n            self,\n            module_path:str, # Path to the Python module\n            config:Optional[Dict[str, Any]]=None # Optional configuration for the plugin\n        ) -&gt; bool: # True if successfully loaded, False otherwise\n        \"Load a plugin directly from a Python module file or package.\"\n    \n    def unload_plugin(\n            self,\n            plugin_name:str # Name of the plugin to unload\n        ) -&gt; bool: # True if successfully unloaded, False otherwise\n        \"Unload a plugin and call its cleanup method.\"\n    \n    def get_plugin(\n            self,\n            plugin_name:str # Name of the plugin to retrieve\n        ) -&gt; Optional[PluginInterface]: # Plugin instance if found, None otherwise\n        \"Get a loaded plugin instance by name.\"\n    \n    def list_plugins(self) -&gt; List[PluginMeta]: # List of metadata for all loaded plugins\n            \"\"\"List all loaded plugins.\"\"\"\n            return list(self.plugins.values())\n    \n        def execute_plugin(\n            self,\n            plugin_name:str, # Name of the plugin to execute\n            *args, # Arguments to pass to the plugin\n            **kwargs # Keyword arguments to pass to the plugin\n        ) -&gt; Any: # Result of the plugin execution\n        \"List all loaded plugins.\"\n    \n    def execute_plugin(\n            self,\n            plugin_name:str, # Name of the plugin to execute\n            *args, # Arguments to pass to the plugin\n            **kwargs # Keyword arguments to pass to the plugin\n        ) -&gt; Any: # Result of the plugin execution\n        \"Execute a plugin's main functionality.\"\n    \n    def enable_plugin(\n            self,\n            plugin_name:str # Name of the plugin to enable\n        ) -&gt; bool: # True if plugin was enabled, False if not found\n        \"Enable a plugin.\"\n    \n    def disable_plugin(\n            self,\n            plugin_name:str # Name of the plugin to disable\n        ) -&gt; bool: # True if plugin was disabled, False if not found\n        \"Disable a plugin without unloading it.\"\n\n\n\nPlugin Metadata (metadata.ipynb)\n\nData structures for plugin metadata\n\n\nImport\nfrom cjm_plugin_system.core.metadata import (\n    PluginMeta\n)\n\n\nClasses\n@dataclass\nclass PluginMeta:\n    \"Metadata about a plugin.\"\n    \n    name: str  # Plugin's unique identifier\n    version: str  # Plugin's version string\n    description: str = ''  # Brief description of the plugin's functionality\n    author: str = ''  # Plugin author's name or organization\n    package_name: str = ''  # Python package name containing the plugin\n    instance: Optional[Any]  # Plugin instance (PluginInterface subclass)\n    enabled: bool = True  # Whether the plugin is enabled\n\n\n\nConfiguration Validation (validation.ipynb)\n\nJSON Schema validation helpers for plugin configuration\n\n\nImport\nfrom cjm_plugin_system.utils.validation import (\n    validate_config,\n    extract_defaults\n)\n\n\nFunctions\ndef validate_config(\n    config:Dict[str, Any], # Configuration to validate\n    schema:Dict[str, Any] # JSON Schema to validate against\n) -&gt; Tuple[bool, Optional[str]]: # (is_valid, error_message)\n    \"Validate a configuration dictionary against a JSON Schema.\"\ndef _basic_validate(\n    config:Dict[str, Any], # Configuration to validate\n    schema:Dict[str, Any] # JSON Schema to validate against\n) -&gt; Tuple[bool, Optional[str]]: # (is_valid, error_message)\n    \"Basic validation without jsonschema library.\"\ndef extract_defaults(\n    schema:Dict[str, Any] # JSON Schema\n) -&gt; Dict[str, Any]: # Default values from schema\n    \"Extract default values from a JSON Schema.\"",
    "crumbs": [
      "cjm-plugin-system"
    ]
  },
  {
    "objectID": "core/manager.html",
    "href": "core/manager.html",
    "title": "Plugin Manager",
    "section": "",
    "text": "The PluginManager class handles the complete lifecycle of plugins: - Discovery via entry points or direct module loading - Loading and initialization - Configuration management - Execution with optional streaming support - Enable/disable/reload functionality - Cleanup and unloading",
    "crumbs": [
      "core",
      "Plugin Manager"
    ]
  },
  {
    "objectID": "core/manager.html#pluginmanager",
    "href": "core/manager.html#pluginmanager",
    "title": "Plugin Manager",
    "section": "",
    "text": "The PluginManager class handles the complete lifecycle of plugins: - Discovery via entry points or direct module loading - Loading and initialization - Configuration management - Execution with optional streaming support - Enable/disable/reload functionality - Cleanup and unloading",
    "crumbs": [
      "core",
      "Plugin Manager"
    ]
  },
  {
    "objectID": "core/manager.html#error-handling-integration",
    "href": "core/manager.html#error-handling-integration",
    "title": "Plugin Manager",
    "section": "Error Handling Integration",
    "text": "Error Handling Integration\nWhen the cjm-error-handling library is installed, PluginManager uses structured errors for better error tracking:\n\nPluginError: Raised for plugin lifecycle failures (discovery, loading, initialization, execution, unloading)\nValidationError: Raised for invalid plugin configuration\n\nThese structured errors provide: - User-friendly messages for display - Debug information for developers - Rich context (plugin_name, operation, package_name, etc.) - Error chaining with original exception cause\nWithout the library: Falls back to returning False or raising standard exceptions (ValueError)\nUsage:\ntry:\n    manager.load_plugin(plugin_meta, config)\nexcept PluginError as e:\n    print(f\"Plugin error: {e.get_user_message()}\")\n    print(f\"Debug: {e.get_debug_message()}\")\n    print(f\"Plugin: {e.plugin_id}\")\nexcept ValidationError as e:\n    print(f\"Config error: {e.get_user_message()}\")\n    if e.validation_errors:\n        print(f\"Validation details: {e.validation_errors}\")\n\nsource\n\nPluginManager\n\n PluginManager (plugin_interface:Type[cjm_plugin_system.core.interface.Plu\n                ginInterface]=&lt;class\n                'cjm_plugin_system.core.interface.PluginInterface'&gt;,\n                entry_point_group:Optional[str]=None)\n\nManages plugin discovery, loading, and lifecycle.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nplugin_interface\nType\nPluginInterface\nBase class/interface plugins must implement\n\n\nentry_point_group\nOptional\nNone\nOptional override for entry point group name\n\n\n\nThis is a generic plugin manager that works with any PluginInterface subclass. It provides: - Automatic discovery via entry points - Manual loading from module files - Configuration management and validation - Plugin enable/disable/reload - Streaming support detection\nThe manager automatically uses the entry_point_group defined in the plugin interface. If not provided explicitly, it reads from plugin_interface.entry_point_group.",
    "crumbs": [
      "core",
      "Plugin Manager"
    ]
  },
  {
    "objectID": "core/manager.html#configuration-management",
    "href": "core/manager.html#configuration-management",
    "title": "Plugin Manager",
    "section": "Configuration Management",
    "text": "Configuration Management\nMethods for managing plugin configuration.\n\nsource\n\nreload_plugin\n\n reload_plugin (plugin_name:str, config:Optional[Dict[str,Any]]=None)\n\nReload a plugin with optional new configuration.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nplugin_name\nstr\n\nName of the plugin to reload\n\n\nconfig\nOptional\nNone\nOptional new configuration\n\n\nReturns\nbool\n\nTrue if successful, False otherwise\n\n\n\n\nsource\n\n\nget_all_plugin_schemas\n\n get_all_plugin_schemas ()\n\nGet configuration schemas for all loaded plugins.\n\nsource\n\n\nvalidate_plugin_config\n\n validate_plugin_config (plugin_name:str, config:Dict[str,Any])\n\nValidate a configuration dictionary for a plugin without applying it.\n\n\n\n\nType\nDetails\n\n\n\n\nplugin_name\nstr\nName of the plugin\n\n\nconfig\nDict\nConfiguration to validate\n\n\nReturns\nTuple\n(is_valid, error_message)\n\n\n\n\nsource\n\n\nupdate_plugin_config\n\n update_plugin_config (plugin_name:str, config:Dict[str,Any],\n                       merge:bool=True)\n\nUpdate a pluginâ€™s configuration and reinitialize it.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nplugin_name\nstr\n\nName of the plugin\n\n\nconfig\nDict\n\nNew configuration\n\n\nmerge\nbool\nTrue\nWhether to merge with existing config or replace entirely\n\n\nReturns\nbool\n\nTrue if successful, False otherwise\n\n\n\n\nsource\n\n\nget_plugin_config\n\n get_plugin_config (plugin_name:str)\n\nGet the current configuration of a plugin.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nplugin_name\nstr\nName of the plugin\n\n\nReturns\nOptional\nCurrent configuration or None if plugin not found\n\n\n\n\nsource\n\n\nget_plugin_config_schema\n\n get_plugin_config_schema (plugin_name:str)\n\nGet the configuration schema for a plugin.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nplugin_name\nstr\nName of the plugin\n\n\nReturns\nOptional\nConfiguration schema or None if plugin not found",
    "crumbs": [
      "core",
      "Plugin Manager"
    ]
  },
  {
    "objectID": "core/manager.html#streaming-support",
    "href": "core/manager.html#streaming-support",
    "title": "Plugin Manager",
    "section": "Streaming Support",
    "text": "Streaming Support\nMethods for managing plugins with streaming capabilities.\n\nsource\n\nget_streaming_plugins\n\n get_streaming_plugins ()\n\nGet a list of all loaded plugins that support streaming.\n\nsource\n\n\ncheck_streaming_support\n\n check_streaming_support (plugin_name:str)\n\nCheck if a plugin supports streaming execution.\n\n\n\n\nType\nDetails\n\n\n\n\nplugin_name\nstr\nName of the plugin to check\n\n\nReturns\nbool\nTrue if plugin supports streaming\n\n\n\n\nsource\n\n\nexecute_plugin_stream\n\n execute_plugin_stream (plugin_name:str, *args, **kwargs)\n\nExecute a plugin with streaming support if available.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nplugin_name\nstr\nName of the plugin to execute\n\n\nargs\nVAR_POSITIONAL\nArguments to pass to the plugin\n\n\nkwargs\nVAR_KEYWORD\n\n\n\nReturns\nGenerator\nGenerator yielding partial results, returns final result\n\n\n\n\n\nExample: Using the PluginManager\n\nimport logging\nfrom cjm_plugin_system.core.interface import PluginInterface\n\n# Create a simple test plugin\nclass TestPlugin(PluginInterface):\n    def __init__(self):\n        self.config = {}\n\n    entry_point_group = 'your.plugins'\n        \n    @property\n    def name(self) -&gt; str:\n        return \"test_plugin\"\n    \n    @property\n    def version(self) -&gt; str:\n        return \"1.0.0\"\n    \n    @staticmethod\n    def get_config_schema():\n        return {\n            \"type\": \"object\",\n            \"properties\": {\n                \"mode\": {\n                    \"type\": \"string\",\n                    \"enum\": [\"fast\", \"slow\"],\n                    \"default\": \"fast\"\n                }\n            },\n            \"required\": [\"mode\"]\n        }\n    \n    def get_current_config(self):\n        defaults = self.get_config_defaults()\n        return {**defaults, **self.config}\n    \n    def initialize(self, config=None):\n        defaults = self.get_config_defaults()\n        self.config = {**defaults, **(config or {})}\n        print(f\"Initialized {self.name} with config: {self.config}\")\n    \n    def execute(self, data):\n        return f\"Processed '{data}' in {self.config['mode']} mode\"\n    \n    def is_available(self):\n        return True\n    \n    def cleanup(self):\n        print(f\"Cleaning up {self.name}\")\n\n\n# Initialize plugin manager\nlogging.basicConfig(level=logging.INFO)\nmanager = PluginManager()\n\nprint(f\"Entry point group: {manager.entry_point_group}\")\nprint(f\"Plugin interface: {manager.plugin_interface.__name__}\")\n\nEntry point group: None\nPlugin interface: PluginInterface\n\n\n\n# Since we don't have actual installed plugins, let's save TestPlugin to a file\n# and load it from the file\nimport tempfile\nimport os\n\n# Create a temporary plugin file\nplugin_code = '''\nfrom cjm_plugin_system.core.interface import PluginInterface\nfrom typing import Dict, Any, Optional\n\nclass DemoPlugin(PluginInterface):\n    def __init__(self):\n        self.config = {}\n\n    entry_point_group = 'your.plugins'\n        \n    @property\n    def name(self) -&gt; str:\n        return \"demo_plugin\"\n    \n    @property\n    def version(self) -&gt; str:\n        return \"1.0.0\"\n    \n    @staticmethod\n    def get_config_schema():\n        return {\n            \"type\": \"object\",\n            \"properties\": {\n                \"mode\": {\n                    \"type\": \"string\",\n                    \"enum\": [\"fast\", \"slow\"],\n                    \"default\": \"fast\"\n                }\n            },\n            \"required\": [\"mode\"]\n        }\n    \n    def get_current_config(self):\n        defaults = self.get_config_defaults()\n        return {**defaults, **self.config}\n    \n    def initialize(self, config=None):\n        defaults = self.get_config_defaults()\n        self.config = {**defaults, **(config or {})}\n    \n    def execute(self, data):\n        return f\"Demo: Processed '{data}' in {self.config['mode']} mode\"\n    \n    def is_available(self):\n        return True\n'''\n\n# Write to temporary file\nwith tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:\n    f.write(plugin_code)\n    temp_plugin_path = f.name\n\nprint(f\"Created temporary plugin at: {temp_plugin_path}\")\n\nCreated temporary plugin at: /tmp/tmp0m3_cnbj.py\n\n\n\n# Load the plugin from file\nsuccess = manager.load_plugin_from_module(temp_plugin_path, config={\"mode\": \"slow\"})\nprint(f\"\\nPlugin loaded: {success}\")\n\n# List loaded plugins\nplugins = manager.list_plugins()\nprint(f\"\\nLoaded plugins: {len(plugins)}\")\nfor p in plugins:\n    print(f\"  - {p.name} v{p.version} (enabled: {p.enabled})\")\n\nINFO:__main__.PluginManager:Loaded plugin from module: demo_plugin\n\n\n\nPlugin loaded: True\n\nLoaded plugins: 1\n  - demo_plugin v1.0.0 (enabled: True)\n\n\n\n# Get and execute plugin\nplugin = manager.get_plugin(\"demo_plugin\")\nif plugin:\n    print(f\"\\nPlugin name: {plugin.name}\")\n    print(f\"Plugin version: {plugin.version}\")\n    print(f\"Is available: {plugin.is_available()}\")\n    \n    # Execute\n    result = manager.execute_plugin(\"demo_plugin\", \"test data\")\n    print(f\"\\nExecution result: {result}\")\n\n\nPlugin name: demo_plugin\nPlugin version: 1.0.0\nIs available: True\n\nExecution result: Demo: Processed 'test data' in slow mode\n\n\n\n# Test configuration management\nprint(\"\\nConfiguration Management:\")\n\n# Get current config\ncurrent_config = manager.get_plugin_config(\"demo_plugin\")\nprint(f\"Current config: {current_config}\")\n\n# Get schema\nimport json\nschema = manager.get_plugin_config_schema(\"demo_plugin\")\nprint(f\"\\nConfig schema:\")\nprint(json.dumps(schema, indent=2))\n\n# Validate config\nis_valid, error = manager.validate_plugin_config(\"demo_plugin\", {\"mode\": \"fast\"})\nprint(f\"\\nValid config test: {is_valid}\")\n\nis_valid, error = manager.validate_plugin_config(\"demo_plugin\", {\"mode\": \"invalid\"})\nprint(f\"Invalid config test: {is_valid}, error: {error}\")\n\n\nConfiguration Management:\nCurrent config: {'mode': 'slow'}\n\nConfig schema:\nnull\n\nValid config test: True\nInvalid config test: False, error: 'invalid' is not one of ['fast', 'slow']\n\nFailed validating 'enum' in schema['properties']['mode']:\n    {'type': 'string', 'enum': ['fast', 'slow'], 'default': 'fast'}\n\nOn instance['mode']:\n    'invalid'\n\n\n\n# Update config\nprint(\"\\nUpdating configuration:\")\nsuccess = manager.update_plugin_config(\"demo_plugin\", {\"mode\": \"fast\"})\nprint(f\"Update successful: {success}\")\n\n# Execute with new config\nresult = manager.execute_plugin(\"demo_plugin\", \"new data\")\nprint(f\"Result after update: {result}\")\n\nINFO:__main__.PluginManager:Updated configuration for plugin: demo_plugin\n\n\n\nUpdating configuration:\nUpdate successful: True\nResult after update: Demo: Processed 'new data' in fast mode\n\n\n\n# Test enable/disable\nprint(\"\\nEnable/Disable Test:\")\nmanager.disable_plugin(\"demo_plugin\")\nprint(f\"Plugin disabled: {not manager.plugins['demo_plugin'].enabled}\")\n\ntry:\n    manager.execute_plugin(\"demo_plugin\", \"data\")\nexcept (ValueError, Exception) as e:\n    # Handle both ValueError (without error handling) and PluginError (with error handling)\n    error_msg = e.get_user_message() if hasattr(e, 'get_user_message') else str(e)\n    print(f\"Expected error when disabled: {error_msg}\")\n\nmanager.enable_plugin(\"demo_plugin\")\nprint(f\"Plugin enabled: {manager.plugins['demo_plugin'].enabled}\")\nresult = manager.execute_plugin(\"demo_plugin\", \"data\")\nprint(f\"Execution after re-enable: {result}\")\n\n\nEnable/Disable Test:\nPlugin disabled: True\nExpected error when disabled: Cannot execute plugin: disabled\nPlugin enabled: True\nExecution after re-enable: Demo: Processed 'data' in fast mode\n\n\n\n# Test streaming support\nprint(\"\\nStreaming Support:\")\nsupports_streaming = manager.check_streaming_support(\"demo_plugin\")\nprint(f\"Plugin supports streaming: {supports_streaming}\")\n\nstreaming_plugins = manager.get_streaming_plugins()\nprint(f\"Streaming plugins: {streaming_plugins}\")\n\n# Try streaming execution (will fall back to regular execution)\nprint(\"\\nStreaming execution:\")\nfor chunk in manager.execute_plugin_stream(\"demo_plugin\", \"stream data\"):\n    print(f\"  Chunk: {chunk}\")\n\nINFO:__main__.PluginManager:Plugin demo_plugin doesn't support streaming, using regular execution\n\n\n\nStreaming Support:\nPlugin supports streaming: False\nStreaming plugins: []\n\nStreaming execution:\n  Chunk: Demo: Processed 'stream data' in fast mode\n\n\n\n# Cleanup\nprint(\"\\nUnloading plugin:\")\nsuccess = manager.unload_plugin(\"demo_plugin\")\nprint(f\"Unload successful: {success}\")\nprint(f\"Remaining plugins: {len(manager.list_plugins())}\")\n\n# Clean up temporary file\nos.unlink(temp_plugin_path)\nprint(f\"\\nCleaned up temporary plugin file\")\n\nINFO:__main__.PluginManager:Unloaded plugin: demo_plugin\n\n\n\nUnloading plugin:\nUnload successful: True\nRemaining plugins: 0\n\nCleaned up temporary plugin file",
    "crumbs": [
      "core",
      "Plugin Manager"
    ]
  }
]