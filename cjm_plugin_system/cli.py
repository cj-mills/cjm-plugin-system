"""CLI tool for declarative plugin management"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/cli.ipynb.

# %% auto 0
__all__ = ['app', 'main', 'run_cmd', 'install_all', 'setup_host']

# %% ../nbs/cli.ipynb 2
import json
import os
import subprocess
import sys
from pathlib import Path
from typing import Optional

import typer
import yaml

app = typer.Typer(help="CJM Plugin System CLI", no_args_is_help=True)

@app.callback()
def main() -> None:
    """CJM Plugin System CLI for managing isolated plugin environments."""
    pass

# %% ../nbs/cli.ipynb 3
def run_cmd(
    cmd: str,  # Shell command to execute
    shell: bool = True,  # Whether to run through shell
    check: bool = True  # Whether to raise on non-zero exit
) -> None:
    """Run a shell command and stream output."""
    print(f"Running: {cmd}")
    subprocess.run(cmd, shell=shell, check=check, executable='/bin/bash')

# %% ../nbs/cli.ipynb 4
def _generate_manifest(
    env_name: str,  # Name of the Conda environment
    package_name: str,  # Package source string (git URL or package name)
    manifest_dir: Path  # Directory to write manifest JSON files
) -> None:
    """Run introspection script inside the target env to generate manifest."""
    print(f"[{env_name}] Generating manifest...")
    
    # Robust Module Name Extraction
    if package_name.startswith("git+"):
        # Case: git+https://github.com/cj-mills/repo-name.git
        url = package_name[4:]
        repo_part = url.split('/')[-1]
        module_name = repo_part.split('.git')[0].replace('-', '_')
    elif package_name.startswith("-e "):
        path = package_name.split("-e ")[1].strip()
        module_name = Path(path).name.replace('-', '_')
    elif "/" in package_name or "\\" in package_name:
        module_name = Path(package_name).name.replace('-', '_')
    else:
        module_name = package_name.replace('-', '_')

    print(f"[{env_name}] Introspecting module: {module_name}")
    
    # Enhanced introspection script that also captures config_schema
    # The script:
    # 1. Gets metadata from get_plugin_metadata()
    # 2. Instantiates the plugin class to get config_schema
    # 3. Merges config_schema into metadata (if not already present)
    introspection_script = f'''
import json
import importlib
from {module_name}.meta import get_plugin_metadata

meta = get_plugin_metadata()

# Try to get config_schema from plugin instance if not in metadata
if "config_schema" not in meta:
    try:
        # Import plugin module and class
        plugin_module = meta.get("module", "{module_name}.plugin")
        plugin_class = meta.get("class", "")
        
        if plugin_module and plugin_class:
            mod = importlib.import_module(plugin_module)
            cls = getattr(mod, plugin_class)
            
            # Instantiate and get config schema
            instance = cls()
            if hasattr(instance, "get_config_schema"):
                meta["config_schema"] = instance.get_config_schema()
            
            # Clean up
            if hasattr(instance, "cleanup"):
                try:
                    instance.cleanup()
                except:
                    pass
    except Exception as e:
        # Config schema extraction is optional - continue without it
        pass

print(json.dumps(meta, indent=2))
'''
    
    # The introspection command
    introspection_cmd = f"conda run -n {env_name} python -c '{introspection_script}'"
    
    try:
        # Check output, capture stdout
        result_bytes = subprocess.check_output(introspection_cmd, shell=True, executable='/bin/bash')
        result_str = result_bytes.decode('utf-8').strip()
        
        # Robust JSON Parsing: 
        # Sometimes 'conda run' leaks warnings into stdout. We try to find the JSON block.
        try:
            start = result_str.find('{')
            end = result_str.rfind('}') + 1
            if start != -1 and end != 0:
                json_str = result_str[start:end]
                meta_json = json.loads(json_str)
            else:
                # Fallback to full string if brackets not found
                meta_json = json.loads(result_str)
        except json.JSONDecodeError as e:
            print(f"ERROR: Failed to parse JSON from introspection output.")
            print(f"Raw Output:\n{result_str}")
            return

        plugin_name = meta_json.get('name', 'unknown')
        out_file = manifest_dir / f"{plugin_name}.json"
        
        # Log detected metadata
        if 'category' in meta_json:
            print(f"[{env_name}] Category: {meta_json['category']}")
        if 'interface' in meta_json:
            print(f"[{env_name}] Interface: {meta_json['interface']}")
        if 'config_schema' in meta_json:
            print(f"[{env_name}] Config schema: captured")
        
        with open(out_file, 'w') as f:
            f.write(json.dumps(meta_json, indent=2))
            
        print(f"[{env_name}] Wrote manifest to {out_file}")
        
    except subprocess.CalledProcessError as e:
        print(f"Error generating manifest for {env_name}:")
        print(e.output.decode() if e.output else str(e))
    except Exception as e:
        print(f"Unexpected error generating manifest: {e}")

# %% ../nbs/cli.ipynb 5
@app.command()
def install_all(
    config_path: str = typer.Option("plugins.yaml", "--config", help="Path to master config file"),
    force: bool = typer.Option(False, help="Force recreation of environments")
) -> None:
    """Install and register all plugins defined in plugins.yaml."""
    if not os.path.exists(config_path):
        typer.echo(f"Config file not found: {config_path}", err=True)
        raise typer.Exit(code=1)

    with open(config_path) as f:
        config = yaml.safe_load(f)

    # Setup manifest directory
    manifest_dir = Path.home() / ".cjm" / "plugins"
    manifest_dir.mkdir(parents=True, exist_ok=True)

    plugins = config.get('plugins', [])
    print(f"Found {len(plugins)} plugins to process.")

    for plugin in plugins:
        name = plugin.get('name')
        env_name = plugin.get('env_name')
        print(f"\n=== Processing {name} ({env_name}) ===")

        # 1. Check if Env Exists
        env_exists = False
        try:
            subprocess.check_call(
                f"conda env list | grep {env_name}", 
                shell=True, stdout=subprocess.DEVNULL
            )
            env_exists = True
        except subprocess.CalledProcessError:
            pass

        # 2. Create Environment
        if not env_exists or force:
            # SAFETY: If forcing, remove old one first to avoid flag issues
            if env_exists and force:
                print(f"Removing existing environment {env_name}...")
                run_cmd(f"conda env remove -n {env_name} -y")

            if 'env_file' in plugin:
                # NOTE: removed --force, added -n explicit override just in case
                # If the yaml file has a 'name' field, '-n' overrides it.
                run_cmd(f"conda env create -f {plugin['env_file']} -n {env_name}")
            elif 'python_version' in plugin:
                run_cmd(f"conda create -n {env_name} python={plugin['python_version']} -y")

        # 3. Install Dependencies (Pip)
        base_pip_cmd = f"conda run -n {env_name} pip install"
        
        if 'interface_libs' in plugin:
            libs = " ".join(plugin['interface_libs'])
            run_cmd(f"{base_pip_cmd} {libs}")

        if 'package' in plugin:
            run_cmd(f"{base_pip_cmd} {plugin['package']}")

        # 4. Generate Manifest
        pkg_source = plugin['package']
        _generate_manifest(env_name, pkg_source, manifest_dir)

    print("\n All operations complete.")

# %% ../nbs/cli.ipynb 7
@app.command("setup-host")
def setup_host(
    config_path: str = typer.Option("plugins.yaml", "--config", help="Path to master config file"),
    yes: bool = typer.Option(False, "--yes", "-y", help="Skip confirmation prompt")
) -> None:
    """Install interface libraries in the current Python environment."""
    if not os.path.exists(config_path):
        typer.echo(f"Config file not found: {config_path}", err=True)
        raise typer.Exit(code=1)

    with open(config_path) as f:
        config = yaml.safe_load(f)

    # Collect unique interface libraries from all plugins
    plugins = config.get('plugins', [])
    all_libs: set[str] = set()
    
    for plugin in plugins:
        interface_libs = plugin.get('interface_libs', [])
        all_libs.update(interface_libs)
    
    # Filter out cjm-plugin-system (already installed since we're running this CLI)
    all_libs = {lib for lib in all_libs 
                if 'cjm-plugin-system.git' not in lib and lib != 'cjm-plugin-system'}
    
    if not all_libs:
        typer.echo("No interface libraries found in config.")
        raise typer.Exit(code=0)

    # Display what will be installed
    typer.echo(f"Reading {config_path}...")
    typer.echo(f"Found {len(all_libs)} unique interface libraries:")
    for lib in sorted(all_libs):
        typer.echo(f"  - {lib}")
    typer.echo("")

    # Confirm with user unless --yes flag provided
    if not yes:
        confirm = typer.confirm("Install these in the current Python environment?")
        if not confirm:
            typer.echo("Aborted.")
            raise typer.Exit(code=0)

    # Install libraries using the current Python interpreter
    libs_str = " ".join(sorted(all_libs))
    run_cmd(f"{sys.executable} -m pip install {libs_str}")
    
    typer.echo("\nHost environment setup complete.")
