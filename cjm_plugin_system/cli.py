"""CLI tool for declarative plugin management"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/cli.ipynb.

# %% auto 0
__all__ = ['app', 'main', 'setup_runtime', 'run_cmd', 'install_all', 'setup_host', 'estimate_size', 'list_plugins',
           'remove_plugin']

# %% ../nbs/cli.ipynb 2
import json
import os
import subprocess
import sys
from pathlib import Path
from typing import Annotated, Optional, List

import typer
import yaml

from cjm_plugin_system.core.config import (
    load_config, set_config, get_config, CondaType, RuntimeMode
)
from cjm_plugin_system.core.platform import (
    run_shell_command, conda_env_exists, get_conda_command, build_conda_command,
    ensure_runtime_available, download_micromamba, get_micromamba_binary_path,
    get_current_platform
)

app = typer.Typer(help="CJM Plugin System CLI", no_args_is_help=True)

@app.callback()
def main(
    ctx:typer.Context,
    cjm_config:Annotated[Optional[Path], typer.Option(
        "--cjm-config",
        help="Path to cjm.yaml configuration file"
    )]=None,
    data_dir:Annotated[Optional[Path], typer.Option(
        "--data-dir",
        help="Override data directory (manifests, logs)"
    )]=None,
    conda_prefix:Annotated[Optional[Path], typer.Option(
        "--conda-prefix",
        help="Override conda/mamba prefix path"
    )]=None,
    conda_type:Annotated[Optional[str], typer.Option(
        "--conda-type",
        help="Conda implementation: micromamba, miniforge, or conda"
    )]=None,
) -> None:
    """CJM Plugin System CLI for managing isolated plugin environments."""
    cfg = load_config(
        config_path=cjm_config,
        data_dir=data_dir,
        conda_prefix=conda_prefix,
        conda_type=conda_type
    )
    set_config(cfg)

# %% ../nbs/cli.ipynb 4
@app.command("setup-runtime")
def setup_runtime(
    force:bool=typer.Option(False, "--force", "-f", help="Re-download even if binary exists")
) -> None:
    """Download and setup micromamba runtime for project-local mode."""
    cfg = get_config()
    
    # Check if micromamba mode
    if cfg.runtime.conda_type != CondaType.MICROMAMBA:
        typer.echo(f"Runtime setup is only needed for micromamba mode.")
        typer.echo(f"Current conda_type: {cfg.runtime.conda_type.value}")
        typer.echo(f"Set 'conda_type: micromamba' in cjm.yaml to use project-local runtime.")
        raise typer.Exit(code=0)
    
    # Determine binary path
    binary_path = get_micromamba_binary_path(cfg)
    
    if binary_path is None:
        typer.echo("Error: Cannot determine micromamba binary path.", err=True)
        typer.echo("Set 'runtime.prefix' or 'runtime.binaries' in cjm.yaml.", err=True)
        raise typer.Exit(code=1)
    
    # Check if already exists
    if binary_path.exists() and not force:
        typer.echo(f"Micromamba already installed at: {binary_path}")
        typer.echo(f"Use --force to re-download.")
        raise typer.Exit(code=0)
    
    # Show what will be done
    platform_str = get_current_platform()
    typer.echo(f"=== Setup Runtime ===\n")
    typer.echo(f"Platform: {platform_str}")
    typer.echo(f"Destination: {binary_path}")
    typer.echo("")
    
    # Create runtime directory structure
    if cfg.runtime.prefix:
        (cfg.runtime.prefix / "bin").mkdir(parents=True, exist_ok=True)
        (cfg.runtime.prefix / "envs").mkdir(parents=True, exist_ok=True)
        typer.echo(f"Created runtime directories at: {cfg.runtime.prefix}")
    
    # Download micromamba
    success = download_micromamba(binary_path, platform_str, show_progress=True)
    
    if success:
        typer.echo(f"\nRuntime setup complete!")
        typer.echo(f"You can now run: cjm-ctl install-all --plugins <plugins.yaml>")
    else:
        typer.echo(f"\nError: Failed to download micromamba.", err=True)
        raise typer.Exit(code=1)

# %% ../nbs/cli.ipynb 5
def _check_runtime_available() -> None:
    """Check if the configured conda runtime is available, exit with helpful message if not."""
    cfg = get_config()
    
    if not ensure_runtime_available(cfg):
        if cfg.runtime.conda_type == CondaType.MICROMAMBA:
            typer.echo("Error: Micromamba runtime not found.", err=True)
            typer.echo("Run 'cjm-ctl setup-runtime' first to download micromamba.", err=True)
        elif cfg.runtime.conda_type == CondaType.MINIFORGE:
            typer.echo("Error: Mamba not found in PATH.", err=True)
            typer.echo("Install miniforge/mambaforge or set conda_type to 'conda'.", err=True)
        else:
            typer.echo("Error: Conda not found in PATH.", err=True)
            typer.echo("Install conda or set the correct conda_type in cjm.yaml.", err=True)
        raise typer.Exit(code=1)

# %% ../nbs/cli.ipynb 6
def _get_conda_cmd_str() -> str:
    """Get the conda/micromamba command string for shell commands."""
    cfg = get_config()
    cmd_parts = get_conda_command(cfg)
    return " ".join(cmd_parts)

# %% ../nbs/cli.ipynb 7
import tempfile
import urllib.request
import urllib.error

def _download_url_to_temp(
    url: str,  # URL to download
    suffix: str = ".yml"  # File suffix for temp file
) -> Optional[Path]:  # Path to temp file or None if failed
    """Download a URL to a temporary file. Returns None if download fails."""
    try:
        # Create a named temp file that won't be auto-deleted
        fd, temp_path = tempfile.mkstemp(suffix=suffix)
        os.close(fd)
        
        print(f"Downloading {url}...")
        urllib.request.urlretrieve(url, temp_path)
        return Path(temp_path)
    except (urllib.error.URLError, urllib.error.HTTPError, IOError) as e:
        print(f"Failed to download {url}: {e}")
        return None


def _resolve_env_file(
    env_file: str  # Path or URL to environment file
) -> tuple[str, Optional[Path]]:  # (resolved_path, temp_file_to_cleanup)
    """Resolve env_file to a local path, downloading if it's a URL.
    
    Returns (local_path, temp_file) where temp_file is set if we created
    a temporary file that should be cleaned up later.
    """
    if env_file.startswith("http://") or env_file.startswith("https://"):
        temp_file = _download_url_to_temp(env_file)
        if temp_file:
            return str(temp_file), temp_file
        else:
            raise RuntimeError(f"Failed to download environment file: {env_file}")
    else:
        # Local path, no cleanup needed
        return env_file, None

# %% ../nbs/cli.ipynb 8
def run_cmd(
    cmd: str,  # Shell command to execute
    check: bool = True  # Whether to raise on non-zero exit
) -> None:
    """Run a shell command and stream output.
    
    Uses the platform's default shell (no hardcoded /bin/bash).
    """
    run_shell_command(cmd, check=check)

# %% ../nbs/cli.ipynb 9
def _generate_manifest(
    env_name: str,  # Name of the Conda environment
    package_name: str,  # Package source string (git URL or package name)
    manifest_dir: Path  # Directory to write manifest JSON files
) -> None:
    """Run introspection script inside the target env to generate manifest."""
    print(f"[{env_name}] Generating manifest...")
    
    # Robust Module Name Extraction
    if package_name.startswith("git+"):
        # Case: git+https://github.com/cj-mills/repo-name.git
        url = package_name[4:]
        repo_part = url.split('/')[-1]
        module_name = repo_part.split('.git')[0].replace('-', '_')
    elif package_name.startswith("-e "):
        path = package_name.split("-e ")[1].strip()
        module_name = Path(path).name.replace('-', '_')
    elif "/" in package_name or "\\" in package_name:
        module_name = Path(package_name).name.replace('-', '_')
    else:
        module_name = package_name.replace('-', '_')

    print(f"[{env_name}] Introspecting module: {module_name}")
    
    # Enhanced introspection script that also captures config_schema
    # The script:
    # 1. Gets metadata from get_plugin_metadata()
    # 2. Instantiates the plugin class to get config_schema
    # 3. Merges config_schema into metadata (if not already present)
    introspection_script = f'''
import json
import importlib
from {module_name}.meta import get_plugin_metadata

meta = get_plugin_metadata()

# Try to get config_schema from plugin instance if not in metadata
if "config_schema" not in meta:
    try:
        # Import plugin module and class
        plugin_module = meta.get("module", "{module_name}.plugin")
        plugin_class = meta.get("class", "")
        
        if plugin_module and plugin_class:
            mod = importlib.import_module(plugin_module)
            cls = getattr(mod, plugin_class)
            
            # Instantiate and get config schema
            instance = cls()
            if hasattr(instance, "get_config_schema"):
                meta["config_schema"] = instance.get_config_schema()
            
            # Clean up
            if hasattr(instance, "cleanup"):
                try:
                    instance.cleanup()
                except:
                    pass
    except Exception as e:
        # Config schema extraction is optional - continue without it
        pass

print(json.dumps(meta, indent=2))
'''
    
    # The introspection command - use configurable conda command
    conda_cmd = _get_conda_cmd_str()
    introspection_cmd = f"{conda_cmd} run -n {env_name} python -c '{introspection_script}'"
    
    try:
        # Check output, capture stdout
        # Use shell=True without explicit executable for cross-platform support
        result = subprocess.run(
            introspection_cmd,
            shell=True,
            capture_output=True,
            text=True,
            check=True
        )
        result_str = result.stdout.strip()
        
        # Robust JSON Parsing: 
        # Sometimes 'conda run' leaks warnings into stdout. We try to find the JSON block.
        try:
            start = result_str.find('{')
            end = result_str.rfind('}') + 1
            if start != -1 and end != 0:
                json_str = result_str[start:end]
                meta_json = json.loads(json_str)
            else:
                # Fallback to full string if brackets not found
                meta_json = json.loads(result_str)
        except json.JSONDecodeError as e:
            print(f"ERROR: Failed to parse JSON from introspection output.")
            print(f"Raw Output:\n{result_str}")
            return

        plugin_name = meta_json.get('name', 'unknown')
        out_file = manifest_dir / f"{plugin_name}.json"
        
        # Log detected metadata
        if 'category' in meta_json:
            print(f"[{env_name}] Category: {meta_json['category']}")
        if 'interface' in meta_json:
            print(f"[{env_name}] Interface: {meta_json['interface']}")
        if 'config_schema' in meta_json:
            print(f"[{env_name}] Config schema: captured")
        
        with open(out_file, 'w') as f:
            f.write(json.dumps(meta_json, indent=2))
            
        print(f"[{env_name}] Wrote manifest to {out_file}")
        
    except subprocess.CalledProcessError as e:
        print(f"Error generating manifest for {env_name}:")
        print(e.stderr if e.stderr else str(e))
    except Exception as e:
        print(f"Unexpected error generating manifest: {e}")

# %% ../nbs/cli.ipynb 10
def _add_conda_env_to_manifest(
    manifest_dir:Path, # Directory containing manifest files
    plugin_name:str, # Plugin name (used for finding manifest file)
    env_name:str # Conda environment name to add
) -> bool: # True if successfully updated
    """Add conda_env field to an existing manifest file."""
    # Find manifest by scanning for matching name
    for manifest_file in manifest_dir.glob("*.json"):
        try:
            with open(manifest_file) as f:
                manifest = json.load(f)
            
            # Check if this is the right manifest (by plugin name in config won't match,
            # so we need to check if it was just created - use the file we just wrote)
            if manifest.get('name'):
                # Add conda_env and write back
                manifest['conda_env'] = env_name
                with open(manifest_file, 'w') as f:
                    json.dump(manifest, f, indent=2)
                return True
        except (json.JSONDecodeError, IOError):
            continue
    
    return False


def _conda_env_exists_configured(
    env_name: str  # Name of the conda environment
) -> bool:  # True if environment exists
    """Check if conda environment exists using configured conda command."""
    cfg = get_config()
    cmd_parts = get_conda_command(cfg)
    # Use the first part as the conda command for conda_env_exists
    conda_cmd = cmd_parts[0]
    
    # For micromamba with root prefix, we need to filter envs by the prefix path
    if cfg.runtime.conda_type == CondaType.MICROMAMBA and cfg.runtime.prefix:
        # micromamba -r <prefix> env list --json returns ALL known envs,
        # so we need to filter by the root prefix path
        try:
            result = subprocess.run(
                cmd_parts + ["env", "list", "--json"],
                capture_output=True,
                text=True
            )
            if result.returncode != 0:
                return False
            
            data = json.loads(result.stdout)
            # Get the absolute prefix path for comparison
            prefix_str = str(cfg.runtime.prefix.resolve())
            
            for path in data.get('envs', []):
                # Only consider envs under our root prefix
                if path.startswith(prefix_str):
                    if Path(path).name == env_name:
                        return True
            return False
        except (subprocess.SubprocessError, json.JSONDecodeError, FileNotFoundError):
            return False
    elif cfg.runtime.conda_type == CondaType.MICROMAMBA:
        # System micromamba without root prefix
        return conda_env_exists(env_name, conda_cmd)
    else:
        return conda_env_exists(env_name, conda_cmd)


@app.command()
def install_all(
    plugins_path:str=typer.Option("plugins.yaml", "--plugins", help="Path to plugins.yaml file"),
    force:bool=typer.Option(False, help="Force recreation of environments")
) -> None:
    """Install and register all plugins defined in plugins.yaml."""
    cfg = get_config()
    
    # Check runtime availability
    _check_runtime_available()
    
    if not os.path.exists(plugins_path):
        typer.echo(f"Plugins file not found: {plugins_path}", err=True)
        raise typer.Exit(code=1)

    with open(plugins_path) as f:
        config = yaml.safe_load(f)

    # Setup manifest directory using config
    manifest_dir = cfg.plugins_dir
    manifest_dir.mkdir(parents=True, exist_ok=True)

    plugins = config.get('plugins', [])
    print(f"Found {len(plugins)} plugins to process.")
    
    # Get the conda command string for shell commands
    conda_cmd = _get_conda_cmd_str()
    
    # Determine if using micromamba (different command syntax)
    is_micromamba = cfg.runtime.conda_type == CondaType.MICROMAMBA
    
    # Track temp files to clean up
    temp_files_to_cleanup: List[Path] = []

    try:
        for plugin in plugins:
            name = plugin.get('name')
            env_name = plugin.get('env_name')
            print(f"\n=== Processing {name} ({env_name}) ===")

            # 1. Check if Env Exists (using configured conda command)
            env_exists = _conda_env_exists_configured(env_name)

            # 2. Create Environment
            if not env_exists or force:
                # SAFETY: If forcing, remove old one first to avoid flag issues
                if env_exists and force:
                    print(f"Removing existing environment {env_name}...")
                    run_cmd(f"{conda_cmd} env remove -n {env_name} -y")

                if 'env_file' in plugin:
                    # Resolve env_file (download if URL)
                    local_env_file, temp_file = _resolve_env_file(plugin['env_file'])
                    if temp_file:
                        temp_files_to_cleanup.append(temp_file)
                    
                    # micromamba uses 'create' directly, conda uses 'env create'
                    if is_micromamba:
                        run_cmd(f"{conda_cmd} create -f {local_env_file} -n {env_name} -y")
                    else:
                        run_cmd(f"{conda_cmd} env create -f {local_env_file} -n {env_name}")
                elif 'python_version' in plugin:
                    run_cmd(f"{conda_cmd} create -n {env_name} python={plugin['python_version']} -y")

            # 3. Install Dependencies (Pip)
            base_pip_cmd = f"{conda_cmd} run -n {env_name} pip install"
            
            if 'interface_libs' in plugin:
                libs = " ".join(plugin['interface_libs'])
                run_cmd(f"{base_pip_cmd} {libs}")

            if 'package' in plugin:
                run_cmd(f"{base_pip_cmd} {plugin['package']}")

            # 4. Generate Manifest
            pkg_source = plugin['package']
            _generate_manifest(env_name, pkg_source, manifest_dir)
            
            # 5. Add conda_env to the generated manifest
            # Find the manifest that was just created and add the env_name
            for manifest_file in manifest_dir.glob("*.json"):
                try:
                    with open(manifest_file) as f:
                        manifest = json.load(f)
                    
                    # Check if this manifest needs conda_env added
                    # (recently generated manifests won't have it)
                    if 'conda_env' not in manifest:
                        # Verify this is likely the right manifest by checking python_path
                        python_path = manifest.get('python_path', '')
                        if env_name in python_path:
                            manifest['conda_env'] = env_name
                            with open(manifest_file, 'w') as f:
                                json.dump(manifest, f, indent=2)
                            print(f"[{env_name}] Added conda_env to manifest")
                            break
                except (json.JSONDecodeError, IOError):
                    continue

        print("\n All operations complete.")
    
    finally:
        # Clean up any temporary files
        for temp_file in temp_files_to_cleanup:
            try:
                temp_file.unlink()
            except IOError:
                pass

# %% ../nbs/cli.ipynb 12
@app.command("setup-host")
def setup_host(
    plugins_path:str=typer.Option("plugins.yaml", "--plugins", help="Path to plugins.yaml file"),
    yes:bool=typer.Option(False, "--yes", "-y", help="Skip confirmation prompt")
) -> None:
    """Install interface libraries in the current Python environment."""
    if not os.path.exists(plugins_path):
        typer.echo(f"Plugins file not found: {plugins_path}", err=True)
        raise typer.Exit(code=1)

    with open(plugins_path) as f:
        config = yaml.safe_load(f)

    # Collect unique interface libraries from all plugins
    plugins = config.get('plugins', [])
    all_libs: set[str] = set()
    
    for plugin in plugins:
        interface_libs = plugin.get('interface_libs', [])
        all_libs.update(interface_libs)
    
    # Filter out cjm-plugin-system (already installed since we're running this CLI)
    all_libs = {lib for lib in all_libs 
                if 'cjm-plugin-system.git' not in lib and lib != 'cjm-plugin-system'}
    
    if not all_libs:
        typer.echo("No interface libraries found in config.")
        raise typer.Exit(code=0)

    # Display what will be installed
    typer.echo(f"Reading {plugins_path}...")
    typer.echo(f"Found {len(all_libs)} unique interface libraries:")
    for lib in sorted(all_libs):
        typer.echo(f"  - {lib}")
    typer.echo("")

    # Confirm with user unless --yes flag provided
    if not yes:
        confirm = typer.confirm("Install these in the current Python environment?")
        if not confirm:
            typer.echo("Aborted.")
            raise typer.Exit(code=0)

    # Install libraries using the current Python interpreter
    libs_str = " ".join(sorted(all_libs))
    run_cmd(f"{sys.executable} -m pip install {libs_str}")
    
    typer.echo("\nHost environment setup complete.")

# %% ../nbs/cli.ipynb 14
def _format_size(
    size_bytes: int  # Size in bytes
) -> str:  # Human-readable size string
    """Format bytes as human-readable string."""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size_bytes < 1024:
            return f"{size_bytes:.1f} {unit}"
        size_bytes /= 1024
    return f"{size_bytes:.1f} PB"


def _get_pypi_size(
    package_spec: str  # Package name or git URL
) -> tuple[int, str]:  # (size_bytes, package_name)
    """Query PyPI for package download size."""
    # Extract package name from various formats
    package_name = package_spec
    
    # Handle git+https://github.com/user/repo-name.git
    if 'github.com' in package_spec and '.git' in package_spec:
        # Extract repo name and convert to package name
        repo_part = package_spec.split('/')[-1]
        package_name = repo_part.replace('.git', '').replace('-', '_')
    # Handle git+https://github.com/user/repo-name (no .git suffix)
    elif package_spec.startswith('git+'):
        repo_part = package_spec.rstrip('/').split('/')[-1]
        package_name = repo_part.replace('-', '_')
    # Handle package[extras] or package>=version
    elif '[' in package_spec:
        package_name = package_spec.split('[')[0]
    elif '>=' in package_spec:
        package_name = package_spec.split('>=')[0]
    elif '==' in package_spec:
        package_name = package_spec.split('==')[0]
    
    try:
        url = f"https://pypi.org/pypi/{package_name}/json"
        with urllib.request.urlopen(url, timeout=10) as resp:
            data = json.loads(resp.read().decode())
        
        # Get the largest file size (usually the wheel)
        urls = data.get('urls', [])
        if urls:
            max_size = max(u.get('size', 0) for u in urls)
            return max_size, package_name
    except (urllib.error.URLError, urllib.error.HTTPError, json.JSONDecodeError):
        pass
    
    return 0, package_name


def _estimate_conda_size(
    env_file: str,  # Path or URL to environment.yml
    env_name: str  # Target environment name
) -> tuple[int, int]:  # (total_bytes, package_count)
    """Estimate conda package sizes using dry-run."""
    cfg = get_config()
    
    # Resolve env_file (download if URL)
    temp_file = None
    try:
        local_env_file, temp_file = _resolve_env_file(env_file)
    except RuntimeError:
        return 0, 0
    
    try:
        cmd_parts = build_conda_command(cfg, "create", "-f", local_env_file, "-n", env_name, "--dry-run", "--json")
        
        # For micromamba, the command is slightly different
        if cfg.runtime.conda_type != CondaType.MICROMAMBA:
            # conda/mamba use "env create" for environment files
            cmd_parts = build_conda_command(cfg, "env", "create", "-f", local_env_file, "-n", env_name, "--dry-run", "--json")
        
        result = subprocess.run(
            cmd_parts,
            capture_output=True, text=True
        )
        
        if result.returncode != 0:
            return 0, 0
        
        data = json.loads(result.stdout)
        fetch_actions = data.get('actions', {}).get('FETCH', [])
        total_size = sum(pkg.get('size', 0) for pkg in fetch_actions)
        return total_size, len(fetch_actions)
        
    except (subprocess.SubprocessError, json.JSONDecodeError):
        return 0, 0
    finally:
        # Clean up temp file if we created one
        if temp_file:
            try:
                temp_file.unlink()
            except IOError:
                pass


def _estimate_pip_sizes(
    packages: list[str]  # List of pip package specs
) -> tuple[int, int, list[tuple[str, int]]]:  # (total_bytes, found_count, [(name, size), ...])
    """Estimate pip package sizes from PyPI."""
    total_size = 0
    found_count = 0
    details = []
    
    for pkg in packages:
        size, name = _get_pypi_size(pkg)
        details.append((name, size))
        if size > 0:
            total_size += size
            found_count += 1
    
    return total_size, found_count, details

# %% ../nbs/cli.ipynb 15
from typing import List

@app.command("estimate-size")
def estimate_size(
    plugins_path:str=typer.Option("plugins.yaml", "--plugins", help="Path to plugins.yaml file"),
    plugin_name:Optional[str]=typer.Option(None, "--plugin", "-p", help="Estimate for a single plugin"),
    verbose:bool=typer.Option(False, "--verbose", "-v", help="Show per-package breakdown")
) -> None:
    """Estimate disk space required for plugin environments."""
    if not os.path.exists(plugins_path):
        typer.echo(f"Plugins file not found: {plugins_path}", err=True)
        raise typer.Exit(code=1)

    with open(plugins_path) as f:
        config = yaml.safe_load(f)

    plugins = config.get('plugins', [])
    
    # Filter to single plugin if specified
    if plugin_name:
        plugins = [p for p in plugins if p.get('name') == plugin_name]
        if not plugins:
            typer.echo(f"Plugin not found: {plugin_name}", err=True)
            raise typer.Exit(code=1)

    typer.echo(f"=== Disk Space Estimates ===\n")
    
    total_conda = 0
    total_pip = 0
    
    for plugin in plugins:
        name = plugin.get('name', 'unknown')
        env_name = plugin.get('env_name', '')
        
        typer.echo(f"{name} (env: {env_name})")
        
        # Estimate conda packages
        conda_size = 0
        conda_count = 0
        if 'env_file' in plugin:
            typer.echo(f"  Analyzing conda environment...")
            conda_size, conda_count = _estimate_conda_size(plugin['env_file'], env_name)
            total_conda += conda_size
            
            if conda_size > 0:
                typer.echo(f"  Conda packages: {_format_size(conda_size)} ({conda_count} packages)")
            else:
                typer.echo(f"  Conda packages: Unable to estimate (env may already exist)")
        
        # Estimate pip packages
        pip_packages: List[str] = []
        if 'interface_libs' in plugin:
            pip_packages.extend(plugin['interface_libs'])
        if 'package' in plugin:
            pip_packages.append(plugin['package'])
        
        if pip_packages:
            pip_size, found_count, details = _estimate_pip_sizes(pip_packages)
            total_pip += pip_size
            
            not_found = len(pip_packages) - found_count
            size_str = _format_size(pip_size) if pip_size > 0 else "unknown"
            
            status_parts = []
            if found_count > 0:
                status_parts.append(f"{found_count} found on PyPI")
            if not_found > 0:
                status_parts.append(f"{not_found} not on PyPI")
            
            typer.echo(f"  Pip packages:   {size_str} compressed ({', '.join(status_parts)})")
            
            if verbose and details:
                for pkg_name, pkg_size in details:
                    if pkg_size > 0:
                        typer.echo(f"    - {pkg_name}: {_format_size(pkg_size)}")
                    else:
                        typer.echo(f"    - {pkg_name}: (not found)")
        
        typer.echo("")
    
    # Summary
    typer.echo("â”€" * 40)
    typer.echo("TOTAL ESTIMATES")
    typer.echo(f"  Conda packages: {_format_size(total_conda)}")
    typer.echo(f"  Pip packages:   {_format_size(total_pip)} (compressed)")
    typer.echo(f"  Combined:       {_format_size(total_conda + total_pip)}")
    typer.echo("")
    typer.echo("Note: Pip sizes are compressed downloads. Installed size is typically 2-5x larger.")
    typer.echo("      Conda estimates require the environment to not already exist.")

# %% ../nbs/cli.ipynb 17
def _get_conda_envs() -> set[str]: # Set of existing conda environment names
    """Get list of existing conda environment names using configured conda command."""
    cfg = get_config()
    cmd_parts = build_conda_command(cfg, "env", "list", "--json")
    
    try:
        result = subprocess.run(
            cmd_parts,
            capture_output=True, text=True
        )
        if result.returncode == 0:
            data = json.loads(result.stdout)
            envs = set()
            
            # For micromamba with root prefix, filter by the prefix path
            if cfg.runtime.conda_type == CondaType.MICROMAMBA and cfg.runtime.prefix:
                prefix_str = str(cfg.runtime.prefix.resolve())
                for path in data.get('envs', []):
                    if path.startswith(prefix_str):
                        env_name = Path(path).name
                        envs.add(env_name)
            else:
                # For conda/mamba or system micromamba, use all envs
                for path in data.get('envs', []):
                    env_name = Path(path).name
                    envs.add(env_name)
            
            return envs
    except (subprocess.SubprocessError, json.JSONDecodeError):
        pass
    return set()


def _get_installed_manifests(
    manifest_dir:Optional[Path]=None # Directory to scan (uses config default if None)
) -> list[dict]: # List of manifest dictionaries
    """Load all manifest JSON files from the manifest directory."""
    if manifest_dir is None:
        manifest_dir = get_config().plugins_dir
    
    manifests = []
    
    if not manifest_dir.exists():
        return manifests
    
    for manifest_file in manifest_dir.glob("*.json"):
        try:
            with open(manifest_file) as f:
                manifest = json.load(f)
                manifest['_manifest_path'] = str(manifest_file)
                manifests.append(manifest)
        except (json.JSONDecodeError, IOError):
            pass
    
    return manifests


def _extract_env_from_python_path(
    python_path:str # Path like /home/user/miniforge3/envs/my-env/bin/python
) -> str: # Extracted environment name or empty string
    """Extract conda environment name from python_path."""
    if not python_path:
        return ''
    
    # Look for /envs/<env_name>/ pattern
    path_parts = Path(python_path).parts
    for i, part in enumerate(path_parts):
        if part == 'envs' and i + 1 < len(path_parts):
            return path_parts[i + 1]
    
    return ''


@app.command("list")
def list_plugins(
    plugins_path:Optional[str]=typer.Option(None, "--plugins", help="Path to plugins.yaml for cross-reference"),
    show_envs:bool=typer.Option(False, "--envs", "-e", help="Show conda environment status")
) -> None:
    """List installed plugins from manifest directory."""
    cfg = get_config()
    manifests = _get_installed_manifests()
    
    if not manifests:
        typer.echo(f"No plugins found in {cfg.plugins_dir}")
        raise typer.Exit(code=0)
    
    # Load config for cross-reference if provided
    config_plugins = {}
    if plugins_path and os.path.exists(plugins_path):
        with open(plugins_path) as f:
            config = yaml.safe_load(f)
        for p in config.get('plugins', []):
            config_plugins[p.get('name')] = p
    
    # Get conda envs if requested
    conda_envs = _get_conda_envs() if show_envs else set()
    
    typer.echo(f"=== Installed Plugins ({len(manifests)}) ===\n")
    
    for manifest in sorted(manifests, key=lambda m: m.get('name', '')):
        name = manifest.get('name', 'unknown')
        version = manifest.get('version', '?')
        category = manifest.get('category', '')
        
        # Get env name from manifest or extract from python_path
        env_name = manifest.get('conda_env', '')
        if not env_name:
            env_name = _extract_env_from_python_path(manifest.get('python_path', ''))
        
        # Basic info line
        cat_str = f" [{category}]" if category else ""
        typer.echo(f"{name} v{version}{cat_str}")
        
        # Environment status
        if show_envs and env_name:
            env_status = "exists" if env_name in conda_envs else "missing"
            typer.echo(f"  Env: {env_name} ({env_status})")
        elif show_envs:
            typer.echo(f"  Env: (not specified in manifest)")
        
        # Cross-reference with config
        if plugins_path:
            if name in config_plugins:
                cfg_env = config_plugins[name].get('env_name', '')
                if cfg_env and cfg_env != env_name:
                    typer.echo(f"  Config env: {cfg_env} (differs from manifest)")
            else:
                typer.echo(f"  (not in {plugins_path})")
        
        typer.echo("")

# %% ../nbs/cli.ipynb 19
@app.command("remove")
def remove_plugin(
    plugin_name:str=typer.Argument(..., help="Name of the plugin to remove"),
    plugins_path:Optional[str]=typer.Option(None, "--plugins", help="Path to plugins.yaml for env name lookup"),
    keep_env:bool=typer.Option(False, "--keep-env", help="Keep the conda environment, only remove manifest"),
    yes:bool=typer.Option(False, "--yes", "-y", help="Skip confirmation prompt")
) -> None:
    """Remove a plugin's manifest and conda environment."""
    cfg = get_config()
    manifest_dir = cfg.plugins_dir
    manifest_path = manifest_dir / f"{plugin_name}.json"
    
    # Find the manifest
    manifest = None
    if manifest_path.exists():
        try:
            with open(manifest_path) as f:
                manifest = json.load(f)
        except (json.JSONDecodeError, IOError):
            pass
    
    if not manifest:
        typer.echo(f"Plugin manifest not found: {plugin_name}", err=True)
        typer.echo(f"  Expected at: {manifest_path}")
        raise typer.Exit(code=1)
    
    # Determine conda environment name (try multiple sources)
    env_name = manifest.get('conda_env', '')
    
    # Fallback 1: Extract from python_path in manifest
    if not env_name:
        env_name = _extract_env_from_python_path(manifest.get('python_path', ''))
    
    # Fallback 2: Check plugins file
    if not env_name and plugins_path and os.path.exists(plugins_path):
        with open(plugins_path) as f:
            config = yaml.safe_load(f)
        for p in config.get('plugins', []):
            if p.get('name') == plugin_name:
                env_name = p.get('env_name', '')
                break
    
    # Check if env exists
    conda_envs = _get_conda_envs()
    env_exists = env_name in conda_envs if env_name else False
    
    # Show what will be removed
    typer.echo(f"=== Remove Plugin: {plugin_name} ===\n")
    typer.echo(f"Manifest: {manifest_path}")
    
    if env_name:
        if env_exists:
            if keep_env:
                typer.echo(f"Conda env: {env_name} (will be kept)")
            else:
                typer.echo(f"Conda env: {env_name} (will be removed)")
        else:
            typer.echo(f"Conda env: {env_name} (does not exist)")
    else:
        typer.echo(f"Conda env: (not specified)")
    
    typer.echo("")
    
    # Confirm
    if not yes:
        confirm = typer.confirm("Proceed with removal?")
        if not confirm:
            typer.echo("Aborted.")
            raise typer.Exit(code=0)
    
    # Remove conda environment using configured command
    if env_name and env_exists and not keep_env:
        typer.echo(f"Removing conda environment: {env_name}...")
        try:
            cmd_parts = build_conda_command(cfg, "env", "remove", "-n", env_name, "-y")
            subprocess.run(cmd_parts, check=True)
            typer.echo(f"  Removed: {env_name}")
        except subprocess.CalledProcessError as e:
            typer.echo(f"  Warning: Failed to remove conda env: {e}", err=True)
    
    # Remove manifest file
    typer.echo(f"Removing manifest: {manifest_path}...")
    try:
        manifest_path.unlink()
        typer.echo(f"  Removed: {manifest_path.name}")
    except IOError as e:
        typer.echo(f"  Error removing manifest: {e}", err=True)
        raise typer.Exit(code=1)
    
    typer.echo(f"\nPlugin '{plugin_name}' removed successfully.")
