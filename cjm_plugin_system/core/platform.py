"""Cross-platform utilities for process management, path handling, and system detection"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/platform.ipynb.

# %% auto 0
__all__ = ['is_windows', 'is_macos', 'is_linux', 'is_apple_silicon', 'get_current_platform', 'get_python_in_env',
           'get_popen_isolation_kwargs', 'terminate_process', 'terminate_self', 'run_shell_command', 'conda_env_exists']

# %% ../../nbs/core/platform.ipynb 3
import os
import platform
import subprocess
import json
from pathlib import Path
from typing import Dict, Any, Optional

# %% ../../nbs/core/platform.ipynb 6
def is_windows() -> bool:
    """Check if running on Windows."""
    return platform.system() == "Windows"


def is_macos() -> bool:
    """Check if running on macOS."""
    return platform.system() == "Darwin"


def is_linux() -> bool:
    """Check if running on Linux."""
    return platform.system() == "Linux"


def is_apple_silicon() -> bool:
    """Check if running on Apple Silicon Mac (for MPS detection)."""
    return is_macos() and platform.machine() == "arm64"

# %% ../../nbs/core/platform.ipynb 8
def get_current_platform() -> str:
    """Get current platform string for manifest filtering.
    
    Returns strings like 'linux-x64', 'darwin-arm64', 'win-x64'.
    """
    system = platform.system().lower()
    machine = platform.machine().lower()
    
    # Normalize system names
    if system == "darwin":
        pass  # Keep as darwin
    elif system == "windows":
        system = "win"
    
    # Normalize architecture
    if machine in ("x86_64", "amd64"):
        arch = "x64"
    elif machine in ("arm64", "aarch64"):
        arch = "arm64"
    else:
        arch = machine
    
    return f"{system}-{arch}"

# %% ../../nbs/core/platform.ipynb 11
def get_python_in_env(
    env_path: Path  # Path to conda environment root
) -> Path:  # Path to Python executable
    """Get the Python executable path for a conda environment.
    
    On Windows: env_path/python.exe
    On Unix: env_path/bin/python
    """
    if is_windows():
        return env_path / "python.exe"
    else:
        return env_path / "bin" / "python"

# %% ../../nbs/core/platform.ipynb 14
def get_popen_isolation_kwargs() -> Dict[str, Any]:
    """Return kwargs for process isolation in subprocess.Popen.
    
    On Unix: Returns {'start_new_session': True}
    On Windows: Returns {'creationflags': CREATE_NEW_PROCESS_GROUP}
    
    Usage:
        process = subprocess.Popen(cmd, **get_popen_isolation_kwargs(), ...)
    """
    if is_windows():
        # CREATE_NEW_PROCESS_GROUP allows the process to be terminated
        # without affecting the parent process
        return {"creationflags": subprocess.CREATE_NEW_PROCESS_GROUP}
    else:
        # start_new_session creates a new process group on Unix
        return {"start_new_session": True}

# %% ../../nbs/core/platform.ipynb 16
def terminate_process(
    process: subprocess.Popen,  # Process to terminate
    timeout: float = 2.0  # Seconds to wait before force kill
) -> None:
    """Terminate a subprocess gracefully, with fallback to force kill.
    
    On all platforms:
    1. Calls process.terminate() (SIGTERM on Unix, TerminateProcess on Windows)
    2. Waits for timeout seconds
    3. If still running, calls process.kill() (SIGKILL on Unix, TerminateProcess on Windows)
    """
    if process is None or process.poll() is not None:
        return  # Already terminated
    
    process.terminate()
    try:
        process.wait(timeout=timeout)
    except subprocess.TimeoutExpired:
        process.kill()
        process.wait()  # Reap the process

# %% ../../nbs/core/platform.ipynb 17
def terminate_self() -> None:
    """Terminate the current process (for worker suicide pact).
    
    On Unix: Sends SIGTERM to self for graceful shutdown
    On Windows: Calls os._exit() since Windows lacks SIGTERM
    """
    if is_windows():
        # Windows doesn't have SIGTERM, use os._exit for immediate termination
        # Exit code 1 indicates abnormal termination
        os._exit(1)
    else:
        import signal
        os.kill(os.getpid(), signal.SIGTERM)

# %% ../../nbs/core/platform.ipynb 19
def run_shell_command(
    cmd: str,  # Shell command to execute
    check: bool = True,  # Whether to raise on non-zero exit
    capture_output: bool = False,  # Whether to capture stdout/stderr
    **kwargs  # Additional kwargs passed to subprocess.run
) -> subprocess.CompletedProcess:
    """Run a shell command cross-platform.
    
    Unlike using shell=True with executable='/bin/bash', this function
    uses the platform's default shell:
    - Linux/macOS: /bin/sh (or $SHELL)
    - Windows: cmd.exe
    """
    print(f"Running: {cmd}")
    return subprocess.run(
        cmd,
        shell=True,
        check=check,
        capture_output=capture_output,
        **kwargs
    )

# %% ../../nbs/core/platform.ipynb 20
def conda_env_exists(
    env_name: str,  # Name of the conda environment
    conda_cmd: str = "conda"  # Conda command (conda, mamba, micromamba)
) -> bool:
    """Check if a conda environment exists (cross-platform).
    
    Uses 'conda env list --json' instead of piping to grep,
    which doesn't work on Windows.
    """
    try:
        result = subprocess.run(
            [conda_cmd, "env", "list", "--json"],
            capture_output=True,
            text=True
        )
        if result.returncode != 0:
            return False
        
        data = json.loads(result.stdout)
        # Extract env names from paths
        for path in data.get('envs', []):
            if Path(path).name == env_name:
                return True
        return False
    except (subprocess.SubprocessError, json.JSONDecodeError, FileNotFoundError):
        return False
